############# ItemProperties.java

package me.bounser.nascraft.database.commands;

import me.bounser.nascraft.config.Config;
import me.bounser.nascraft.market.MarketManager;
import me.bounser.nascraft.market.unit.Item;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;

public class ItemProperties {

    public static void saveItem(Connection connection, Item item) {

        try {
            String sql = "SELECT stock FROM items WHERE identifier=?;";

            PreparedStatement prep = connection.prepareStatement(sql);
            prep.setString(1, item.getIdentifier());
            ResultSet rs = prep.executeQuery();

            if (rs.next()) {
                String sqlReplace = "REPLACE INTO items (lastprice, lowest, highest, stock, taxes, identifier) VALUES (?, ?, ?, ?, ?, ?);";
                PreparedStatement prepReplace = connection.prepareStatement(sqlReplace);

                prepReplace.setDouble(1, item.getPrice().getValue());
                prepReplace.setDouble(2, item.getPrice().getHistoricalLow());
                prepReplace.setDouble(3, item.getPrice().getHistoricalHigh());
                prepReplace.setDouble(4, item.getPrice().getStock());
                prepReplace.setDouble(5, item.getCollectedTaxes());

                prepReplace.setString(6, item.getIdentifier());

                prepReplace.executeUpdate();
            } else {
                String sqlInsert = "INSERT INTO items (lastprice, lowest, highest, stock, taxes, identifier) VALUES (?, ?, ?, ?, ?, ?);";
                PreparedStatement prepInsert = connection.prepareStatement(sqlInsert);

                prepInsert.setDouble(1, item.getPrice().getValue());
                prepInsert.setDouble(2, item.getPrice().getHistoricalLow());
                prepInsert.setDouble(3, item.getPrice().getHistoricalHigh());
                prepInsert.setDouble(4, item.getPrice().getStock());
                prepInsert.setDouble(5, item.getCollectedTaxes());

                prepInsert.setString(6, item.getIdentifier());

                prepInsert.executeUpdate();
            }
        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
    }

    public static void retrieveItem(Connection connection, Item item) {

        try {
            String sql = "SELECT lowest, highest, stock, taxes FROM items WHERE identifier=?;";

            PreparedStatement prep = connection.prepareStatement(sql);
            prep.setString(1, item.getIdentifier());
            ResultSet rs = prep.executeQuery();

            if (rs.next()) {
                item.getPrice().setStock(rs.getInt("stock"));
                item.getPrice().setHistoricalHigh(rs.getFloat("highest"));
                item.getPrice().setHistoricalLow(rs.getFloat("lowest"));
                item.setCollectedTaxes(rs.getFloat("taxes"));
            } else {
                String sqlinsert = "INSERT INTO items (identifier, lastprice, lowest, highest, stock, taxes) VALUES (?,?,?,?,?,?);";

                PreparedStatement insertPrep = connection.prepareStatement(sqlinsert);
                insertPrep.setString(1, item.getIdentifier());
                insertPrep.setFloat(2, Config.getInstance().getInitialPrice(item.getIdentifier()));
                insertPrep.setFloat(3, Config.getInstance().getInitialPrice(item.getIdentifier()));
                insertPrep.setFloat(4, Config.getInstance().getInitialPrice(item.getIdentifier()));
                insertPrep.setFloat(5, 0);
                insertPrep.setFloat(6, 0);

                item.getPrice().setStock(0);
                item.getPrice().setHistoricalHigh(Config.getInstance().getInitialPrice(item.getIdentifier()));
                item.getPrice().setHistoricalLow(Config.getInstance().getInitialPrice(item.getIdentifier()));
                item.setCollectedTaxes(0);

                insertPrep.executeUpdate();
            }

        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
    }

    public static float retrieveLastPrice(Connection connection, Item item) {

        try {
            String selectSQL = "SELECT lastprice FROM items WHERE identifier = ?;";
            PreparedStatement preparedStatement = connection.prepareStatement(selectSQL);

            preparedStatement.setString(1, item.getIdentifier());

            ResultSet resultSet = preparedStatement.executeQuery();

            if (resultSet.next()) {
                return resultSet.getFloat("lastprice");
            } else {
                return Config.getInstance().getInitialPrice(item.getIdentifier());
            }

        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
    }

    public static void retrieveItems(Connection connection) {

        try {
            String selectSQL = "SELECT stock, identifier FROM items;";

            PreparedStatement preparedStatement = connection.prepareStatement(selectSQL);

            ResultSet resultSet = preparedStatement.executeQuery();

            while (resultSet.next()) {

                String identifier = resultSet.getString("identifier");

                Item item = MarketManager.getInstance().getItem(identifier);

                if (item == null) continue;

                if (item.isParent()) {
                    item.getPrice().setStock(resultSet.getFloat("stock"));
                }

            }

        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
    }

}


############# HistorialData.java

package me.bounser.nascraft.database.commands;

import me.bounser.nascraft.database.commands.resources.NormalisedDate;
import me.bounser.nascraft.market.unit.Item;
import me.bounser.nascraft.market.unit.stats.Instant;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.time.LocalDateTime;
import java.util.LinkedList;
import java.util.List;

public class HistorialData {

    public static void saveDayPrice(Connection connection, Item item, Instant instant) {

        try {
            String insert = "INSERT INTO prices_day (day, identifier, date, price, volume) VALUES (?,?,?,?,?);";

            PreparedStatement insertStatement = connection.prepareStatement(insert);

            insertStatement.setInt(1,NormalisedDate. getDays());
            insertStatement.setString(2, item.getIdentifier());
            insertStatement.setString(3, instant.getLocalDateTime().toString());
            insertStatement.setDouble(4, instant.getPrice());
            insertStatement.setInt(5, instant.getVolume());

            insertStatement.executeUpdate();

            String deleteQuery = "DELETE FROM prices_day WHERE day < ?;";

            PreparedStatement deleteStatement = connection.prepareStatement(deleteQuery);

            deleteStatement.setInt(1, NormalisedDate.getDays()-2);

            deleteStatement.executeUpdate();

        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
    }

    public static void saveMonthPrice(Connection connection, Item item, Instant instant) {

        try {
            String select = "SELECT date FROM prices_month WHERE identifier=? ORDER BY id DESC LIMIT 1;";

            PreparedStatement preparedStatement = connection.prepareStatement(select);

            preparedStatement.setString(1, item.getIdentifier());

            ResultSet resultSet = preparedStatement.executeQuery();

            if (!resultSet.next()) {

                String insert = "INSERT INTO prices_month (day, date, identifier, price, volume) VALUES (?,?,?,?,?);";

                PreparedStatement insertStatement = connection.prepareStatement(insert);

                insertStatement.setInt(1, NormalisedDate.getDays());
                insertStatement.setString(2, instant.getLocalDateTime().toString());
                insertStatement.setString(3, item.getIdentifier());
                insertStatement.setDouble(4, instant.getPrice());
                insertStatement.setInt(5, instant.getVolume());

                insertStatement.executeUpdate();
            } else if (LocalDateTime.parse(resultSet.getString("date")).isBefore(LocalDateTime.now().minusHours(4))) {

                String selectDay = "SELECT date, price, volume FROM prices_day WHERE identifier=? ORDER BY id DESC LIMIT 48;";

                PreparedStatement preparedStatementDay = connection.prepareStatement(selectDay);

                preparedStatementDay.setString(1, item.getIdentifier());

                ResultSet resultSetDay = preparedStatementDay.executeQuery();

                if (!resultSetDay.next()) {

                    String insert = "INSERT INTO prices_month (day, date, identifier, price, volume) VALUES (?,?,?,?,?);";

                    PreparedStatement insertStatement = connection.prepareStatement(insert);

                    insertStatement.setInt(1, NormalisedDate.getDays());
                    insertStatement.setString(2, instant.getLocalDateTime().toString());
                    insertStatement.setString(3, item.getIdentifier());
                    insertStatement.setDouble(4, instant.getPrice());
                    insertStatement.setInt(5, instant.getVolume());

                    insertStatement.executeUpdate();

                } else {

                    double averagePrice = 0;
                    int totalVolume = 0;

                    int i = 0;

                    while (resultSetDay.next()) {
                        if (LocalDateTime.parse(resultSetDay.getString("date")).isAfter(LocalDateTime.now().minusHours(4))) {
                            i++;
                            averagePrice += resultSetDay.getDouble("price");
                            totalVolume += resultSetDay.getInt("volume");
                        }
                    }

                    if (averagePrice == 0) return;

                    String insert = "INSERT INTO prices_month (day, date, identifier, price, volume) VALUES (?,?,?,?,?);";

                    PreparedStatement insertStatement = connection.prepareStatement(insert);

                    insertStatement.setInt(1, NormalisedDate.getDays());
                    insertStatement.setString(2, LocalDateTime.now().minusHours(2).toString());
                    insertStatement.setString(3, item.getIdentifier());
                    insertStatement.setDouble(4, averagePrice/i);
                    insertStatement.setInt(5, totalVolume);

                    insertStatement.executeUpdate();
                }

                String deleteQuery = "DELETE FROM prices_month WHERE day < ?;";

                PreparedStatement deleteStatement = connection.prepareStatement(deleteQuery);

                deleteStatement.setInt(1, NormalisedDate.getDays()-31);
                deleteStatement.executeUpdate();
            }

        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
    }

    public static void saveHistoryPrices(Connection connection, Item item, Instant instant) {

        try {
            String select = "SELECT date FROM prices_history WHERE day=? AND identifier=?;";

            PreparedStatement preparedStatement = connection.prepareStatement(select);

            preparedStatement.setInt(1, NormalisedDate.getDays());

            preparedStatement.setString(2, item.getIdentifier());

            ResultSet resultSet = preparedStatement.executeQuery();

            if (!resultSet.next()){

                String selectMonth = "SELECT date, price, volume FROM prices_month WHERE identifier=? ORDER BY id DESC LIMIT 6;";

                PreparedStatement preparedStatementMonth = connection.prepareStatement(selectMonth);

                preparedStatementMonth.setString(1, item.getIdentifier());

                ResultSet resultSetMonth = preparedStatementMonth.executeQuery();

                if (!resultSetMonth.next()) {

                    String insert = "INSERT INTO prices_history (day, date, identifier, price, volume) VALUES (?,?,?,?,?);";

                    PreparedStatement insertStatement = connection.prepareStatement(insert);

                    insertStatement.setInt(1, NormalisedDate.getDays());
                    insertStatement.setString(2, instant.getLocalDateTime().toString());
                    insertStatement.setString(3, item.getIdentifier());
                    insertStatement.setDouble(4, instant.getPrice());
                    insertStatement.setInt(5, instant.getVolume());

                    insertStatement.executeUpdate();

                } else {
                    double averagePrice = 0;
                    int totalVolume = 0;

                    int i = 0;

                    while (resultSetMonth.next()) {
                        if (LocalDateTime.parse(resultSetMonth.getString("date")).isAfter(LocalDateTime.now().minusHours(24))) {
                            i++;
                            averagePrice += resultSetMonth.getDouble("price");
                            totalVolume += resultSetMonth.getInt("volume");
                        }
                    }

                    String insert = "INSERT INTO prices_history (day, date, identifier, price, volume) VALUES (?,?,?,?,?);";

                    PreparedStatement insertStatement = connection.prepareStatement(insert);

                    insertStatement.setInt(1, NormalisedDate.getDays());
                    insertStatement.setString(2, LocalDateTime.now().minusHours(12).toString());
                    insertStatement.setString(3, item.getIdentifier());
                    insertStatement.setDouble(4, averagePrice/i);
                    insertStatement.setInt(5, totalVolume);

                    insertStatement.executeUpdate();
                }
            }

        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
    }


    public static List<Instant> getDayPrices(Connection connection, Item item) {

        List<Instant> prices = new LinkedList<>();

        try {
            String select = "SELECT date FROM prices_day WHERE identifier=? ORDER BY id DESC LIMIT 1;";

            PreparedStatement preparedStatement = connection.prepareStatement(select);

            preparedStatement.setString(1, item.getIdentifier());

            ResultSet resultSet = preparedStatement.executeQuery();

            if (!resultSet.next()) {

                prices.add(new Instant(LocalDateTime.now().minusHours(24), 0, 0));
                prices.add(new Instant(LocalDateTime.now().minusMinutes(5), 0, 0));

                prices.add(new Instant(LocalDateTime.now(), item.getPrice().getValue(), item.getVolume()));

            } else {

                String select288 = "SELECT date, price, volume FROM prices_day WHERE identifier=? ORDER BY id DESC LIMIT 288;";

                PreparedStatement preparedStatement288 = connection.prepareStatement(select288);

                preparedStatement288.setString(1, item.getIdentifier());

                ResultSet resultSet1 = preparedStatement288.executeQuery();

                while (resultSet1.next()) {

                    LocalDateTime time = LocalDateTime.parse(resultSet1.getString("date"));

                    double price = resultSet1.getDouble("price");

                    if (time.isAfter(LocalDateTime.now().minusHours(24)) && price != 0) {
                        prices.add(new Instant(
                                time,
                                resultSet1.getDouble("price"),
                                resultSet1.getInt("volume")
                        ));

                    }
                }

                prices.add(0, new Instant(LocalDateTime.now().minusHours(24), 0, 0));

                prices.add(new Instant(LocalDateTime.now(), item.getPrice().getValue(), item.getVolume()));
            }

        } catch (SQLException e) {
            throw new RuntimeException(e);
        }

        return prices;
    }

    public static List<Instant> getMonthPrices(Connection connection, Item item) {

        List<Instant> prices = new LinkedList<>();

        try {
            String select = "SELECT date FROM prices_month WHERE identifier=? ORDER BY id DESC LIMIT 1;";

            PreparedStatement preparedStatement = connection.prepareStatement(select);

            preparedStatement.setString(1, item.getIdentifier());

            ResultSet resultSet = preparedStatement.executeQuery();

            if (!resultSet.next()) {

                prices.add(new Instant(LocalDateTime.now().minusDays(30), 0, 0));
                prices.add(new Instant(LocalDateTime.now().minusMinutes(5), 0, 0));

                prices.add(new Instant(LocalDateTime.now(), item.getPrice().getValue(), item.getVolume()));

            } else {

                String select288 = "SELECT date, price, volume FROM prices_month WHERE identifier=? ORDER BY id DESC LIMIT 400;";

                PreparedStatement preparedStatement288 = connection.prepareStatement(select288);

                preparedStatement288.setString(1, item.getIdentifier());

                ResultSet resultSet1 = preparedStatement288.executeQuery();

                while (resultSet1.next()) {

                    LocalDateTime time = LocalDateTime.parse(resultSet1.getString("date"));

                    if (time.isAfter(LocalDateTime.now().minusDays(30))) {
                        prices.add(new Instant(
                                time,
                                resultSet1.getDouble("price"),
                                resultSet1.getInt("volume")
                        ));

                    }
                }

                prices.add(0, new Instant(LocalDateTime.now().minusDays(30), 0, 0));

                prices.add(new Instant(LocalDateTime.now(), item.getPrice().getValue(), item.getVolume()));
            }

        } catch (SQLException e) {
            throw new RuntimeException(e);
        }

        return prices;
    }

    public static List<Instant> getYearPrices(Connection connection, Item item) {

        List<Instant> prices = new LinkedList<>();

        try {
            String select = "SELECT day FROM prices_history WHERE identifier=? ORDER BY day DESC LIMIT 1;";

            PreparedStatement preparedStatement = connection.prepareStatement(select);

            preparedStatement.setString(1, item.getIdentifier());

            ResultSet resultSet = preparedStatement.executeQuery();

            if (!resultSet.next()) {

                prices.add(new Instant(LocalDateTime.now().minusDays(365), 0, 0));
                prices.add(new Instant(LocalDateTime.now().minusMinutes(5), 0, 0));

                prices.add(new Instant(LocalDateTime.now(), item.getPrice().getValue(), item.getVolume()));

            } else {

                String select288 = "SELECT day, price, volume FROM prices_history WHERE identifier=? ORDER BY day DESC LIMIT 385;";

                PreparedStatement preparedStatement288 = connection.prepareStatement(select288);

                preparedStatement288.setString(1, item.getIdentifier());

                ResultSet resultSet1 = preparedStatement288.executeQuery();

                while (resultSet1.next()) {

                    LocalDateTime time = LocalDateTime.of(2023, 1, 1, 1, 1).plusDays(resultSet1.getInt("day"));

                    if (time.isAfter(LocalDateTime.now().minusDays(365))) {
                        prices.add(new Instant(
                                time,
                                resultSet1.getDouble("price"),
                                resultSet1.getInt("volume")
                        ));

                    }
                }

                prices.add(new Instant(LocalDateTime.now().minusDays(365), 0, 0));
                prices.add(new Instant(LocalDateTime.now(), item.getPrice().getValue(), item.getVolume()));
            }

        } catch (SQLException e) {
            throw new RuntimeException(e);
        }

        return prices;
    }

    public static List<Instant> getAllPrices(Connection connection, Item item) {

        List<Instant> prices = new LinkedList<>();

        try {
            String select = "SELECT day FROM prices_history WHERE identifier=? ORDER BY day DESC LIMIT 1;";

            PreparedStatement preparedStatement = connection.prepareStatement(select);

            preparedStatement.setString(1, item.getIdentifier());

            ResultSet resultSet = preparedStatement.executeQuery();

            if (!resultSet.next()) {

                prices.add(new Instant(LocalDateTime.now().minusDays(30), 0, 0));
                prices.add(new Instant(LocalDateTime.now().minusMinutes(5), 0, 0));

                prices.add(new Instant(LocalDateTime.now(), item.getPrice().getValue(), item.getVolume()));

            } else {

                String select288 = "SELECT day, price, volume FROM prices_history WHERE identifier=? ORDER BY day DESC;";

                PreparedStatement preparedStatement288 = connection.prepareStatement(select288);

                preparedStatement288.setString(1, item.getIdentifier());

                ResultSet resultSet1 = preparedStatement288.executeQuery();

                while (resultSet1.next()) {

                    LocalDateTime time = LocalDateTime.of(2023, 1, 1, 1, 1);

                    prices.add(new Instant(
                            time.plusDays(resultSet1.getInt("day")),
                            resultSet1.getDouble("price"),
                            resultSet1.getInt("volume")
                    ));
                }

                prices.add(new Instant(LocalDateTime.now(), item.getPrice().getValue(), item.getVolume()));

                prices.add(new Instant(LocalDateTime.now(), item.getPrice().getValue(), item.getVolume()));
            }

        } catch (SQLException e) {
            throw new RuntimeException(e);
        }

        return prices;
    }

    public static Double getPriceOfDay(Connection connection, String identifier, int day) {

        try {
            String select = "SELECT price FROM prices_history WHERE identifier=? AND day=?;";

            PreparedStatement preparedStatement = connection.prepareStatement(select);

            preparedStatement.setString(1, identifier);
            preparedStatement.setInt(2, day);

            ResultSet resultSet = preparedStatement.executeQuery();

            if (!resultSet.next()) return 0.0;

            return resultSet.getDouble("price");

        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
    }

}


########### DiscordLink.java

package me.bounser.nascraft.database.commands;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.UUID;

public class DiscordLink {

    public static void saveLink(Connection connection, String userId, UUID uuid, String nickname) {
        try {
            String sql = "INSERT INTO discord_links (userid, uuid, nickname) VALUES (?,?,?);";
            PreparedStatement prep = connection.prepareStatement(sql);
            prep.setString(1, userId);
            prep.setString(2, uuid.toString());
            prep.setString(3, nickname);
            prep.executeUpdate();

        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
    }

    public static void removeLink(Connection connection, String userId) {
        try {
            String sql = "DELETE FROM discord_links WHERE userid=?;";
            PreparedStatement prep = connection.prepareStatement(sql);
            prep.setString(1, userId);
            prep.executeUpdate();
        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
    }

    public static UUID getUUID(Connection connection, String userId) {
        try {
            String sql = "SELECT uuid FROM discord_links WHERE userid=?;";
            PreparedStatement prep = connection.prepareStatement(sql);
            prep.setString(1, userId);
            ResultSet resultSet = prep.executeQuery();

            if (resultSet.next()) { return UUID.fromString(resultSet.getString("uuid")); }
            else { return null; }

        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
    }

    public static String getNickname(Connection connection, String userId) {
        try {
            String sql = "SELECT nickname FROM discord_links WHERE userid=?;";
            PreparedStatement prep = connection.prepareStatement(sql);
            prep.setString(1, userId);
            ResultSet resultSet = prep.executeQuery();

            if (resultSet.next()) { return resultSet.getString("nickname"); }
            else { return null; }

        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
    }

    public static String getUserId(Connection connection, UUID uuid) {
        try {
            String sql = "SELECT userid FROM discord_links WHERE uuid=?;";
            PreparedStatement prep = connection.prepareStatement(sql);
            prep.setString(1, uuid.toString());
            ResultSet resultSet = prep.executeQuery();

            if (resultSet.next()) {
                return resultSet.getString("userid");
            } else {
                return null;
            }
        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
    }

}


########### Debt.java

package me.bounser.nascraft.database.commands;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.HashMap;
import java.util.UUID;

public class Debt {

    public static void increaseDebt(Connection connection, UUID uuid, double debt) {

        try {
            String sql1 = "SELECT debt FROM loans WHERE uuid=?;";
            PreparedStatement prep1 =  connection.prepareStatement(sql1);
            prep1.setString(1, uuid.toString());
            ResultSet resultSet = prep1.executeQuery();

            if(resultSet.next()) {
                String sql2 = "UPDATE loans SET debt=? WHERE uuid=?;";
                PreparedStatement prep2 =  connection.prepareStatement(sql2);
                prep2.setDouble(1, debt + resultSet.getDouble("debt"));
                prep2.setString(2, uuid.toString());
                prep2.executeUpdate();
            } else {
                String sql2 = "INSERT INTO loans (uuid, debt) VALUES (?,?);";
                PreparedStatement prep2 =  connection.prepareStatement(sql2);
                prep2.setString(1, uuid.toString());
                prep2.setDouble(2, debt);
                prep2.executeUpdate();
            }
        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
    }

    public static void decreaseDebt(Connection connection, UUID uuid, double debt) {

        try {
            String sql1 = "SELECT debt FROM loans WHERE uuid=?;";
            PreparedStatement prep1 =  connection.prepareStatement(sql1);
            prep1.setString(1, uuid.toString());
            ResultSet resultSet = prep1.executeQuery();

            if(resultSet.next()) {

                if (resultSet.getDouble("debt") - debt <= 0) {

                    String sql2 = "DELETE FROM loans WHERE uuid=?;";
                    PreparedStatement prep2 =  connection.prepareStatement(sql2);
                    prep2.setString(1, uuid.toString());
                    prep2.executeUpdate();

                } else {
                    String sql2 = "UPDATE loans SET debt=? WHERE uuid=?;";
                    PreparedStatement prep2 =  connection.prepareStatement(sql2);
                    prep2.setDouble(1, resultSet.getDouble("debt") - debt);
                    prep2.setString(2, uuid.toString());
                    prep2.executeUpdate();
                }
            }
        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
    }

    public static double getDebt(Connection connection, UUID uuid) {

        try {
            String sql1 = "SELECT debt FROM loans WHERE uuid=?;";
            PreparedStatement prep1 =  connection.prepareStatement(sql1);
            prep1.setString(1, uuid.toString());
            ResultSet resultSet = prep1.executeQuery();

            if(resultSet.next()) {
                return resultSet.getDouble("debt");
            } else {
                return 0;
            }

        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
    }

    public static HashMap<UUID, Double> getUUIDAndDebt(Connection connection) {
        HashMap<UUID, Double> debtors = new HashMap<>();

        try {
            String sql = "SELECT uuid, debt FROM loans WHERE debt > 0;";

            PreparedStatement prep = connection.prepareStatement(sql);
            ResultSet rs = prep.executeQuery();

            while (rs.next()) {
                String uuidString = rs.getString("uuid");
                UUID uuid = UUID.fromString(uuidString);
                Double debt = rs.getDouble("debt");
                debtors.put(uuid, debt);
            }

            return debtors;

        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
    }

    public static void addInterestPaid(Connection connection, UUID uuid, Double interest) {

        try {
            String sql1 = "SELECT paid FROM interests WHERE uuid=?;";
            PreparedStatement prep1 =  connection.prepareStatement(sql1);
            prep1.setString(1, uuid.toString());
            ResultSet resultSet = prep1.executeQuery();

            if(resultSet.next()) {
                String sql2 = "UPDATE interests SET paid=? WHERE uuid=?;";
                PreparedStatement prep2 =  connection.prepareStatement(sql2);
                prep2.setDouble(1, interest + resultSet.getDouble("paid"));
                prep2.setString(2, uuid.toString());
                prep2.executeUpdate();
            } else {
                String sql2 = "INSERT INTO interests (uuid, paid) VALUES (?,?);";
                PreparedStatement prep2 =  connection.prepareStatement(sql2);
                prep2.setString(1, uuid.toString());
                prep2.setDouble(2, interest);
                prep2.executeUpdate();
            }
        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
    }

    public static HashMap<UUID, Double> getUUIDAndInterestsPaid(Connection connection) {
        HashMap<UUID, Double> payers = new HashMap<>();

        try {
            String sql = "SELECT uuid, paid FROM interests;";

            PreparedStatement prep = connection.prepareStatement(sql);
            ResultSet rs = prep.executeQuery();

            while (rs.next()) {
                String uuidString = rs.getString("uuid");
                UUID uuid = UUID.fromString(uuidString);
                Double debt = rs.getDouble("paid");
                payers.put(uuid, debt);
            }

            return payers;

        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
    }

    public static double getInterestsPaid(Connection connection, UUID uuid) {

        try {
            String sql = "SELECT paid FROM interests WHERE uuid=?;";

            PreparedStatement prep = connection.prepareStatement(sql);
            prep.setString(1, uuid.toString());
            ResultSet rs = prep.executeQuery();

            if (rs.next())
                return rs.getDouble("paid");

            return 0;

        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
    }

    public static double getAllOutstandingDebt(Connection connection) {

        try {
            String sql = "SELECT SUM(debt) AS total_debt FROM loans;;";

            PreparedStatement prep = connection.prepareStatement(sql);
            ResultSet rs = prep.executeQuery();

            if (rs.next())
                return rs.getDouble("total_debt");

            return 0;

        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
    }

    public static double getAllInterestsPaid(Connection connection) {

        try {
            String sql = "SELECT SUM(paid) AS total_paid FROM interests;;";

            PreparedStatement prep = connection.prepareStatement(sql);
            ResultSet rs = prep.executeQuery();

            if (rs.next())
                return rs.getDouble("total_paid");

            return 0;

        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
    }

}


########### Alerts.java

package me.bounser.nascraft.database.commands;

import me.bounser.nascraft.config.Config;
import me.bounser.nascraft.database.commands.resources.NormalisedDate;
import me.bounser.nascraft.discord.alerts.DiscordAlerts;
import me.bounser.nascraft.market.unit.Item;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;

public class Alerts {

    public static void addAlert(Connection connection, String userid, Item item, double price) {

        try {
            String sql = "INSERT INTO alerts (day, userid, identifier, price) VALUES (?, ?, ?, ?);";

            PreparedStatement prep = connection.prepareStatement(sql);
            prep.setInt(1, NormalisedDate.getDays());
            prep.setString(2, userid);
            prep.setString(3, item.getIdentifier());
            prep.setDouble(4, price);
            prep.executeUpdate();

        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
    }

    public static void removeAlert(Connection connection, String userid, Item item) {

        try {
            String sql = "DELETE FROM alerts WHERE userid = ? AND identifier = ?;";

            PreparedStatement prep = connection.prepareStatement(sql);
            prep.setString(1, userid);
            prep.setString(2, item.getIdentifier());
            prep.executeUpdate();

        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
    }

    public static void retrieveAlerts(Connection connection) {

        try {
            String sql = "SELECT userid, identifier, price FROM alerts;";
            PreparedStatement prep = connection.prepareStatement(sql);
            ResultSet resultSet = prep.executeQuery();

            while (resultSet.next())
                DiscordAlerts.getInstance().setAlert(resultSet.getString("userid"), resultSet.getString("identifier"), resultSet.getDouble("price"));

        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
    }

    public static void removeAllAlerts(Connection connection, String userId) {

        try {
            String sql = "DELETE FROM alerts WHERE userid=?";
            PreparedStatement prep = connection.prepareStatement(sql);
            prep.setString(1, userId);
            prep.executeUpdate();

        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
    }

    public static void purgeAlerts(Connection connection) {

        int expiration = Config.getInstance().getAlertsDaysUntilExpired();
        int days = NormalisedDate.getDays();

        try {
            String sql = "DELETE FROM alerts WHERE day < ?;";

            PreparedStatement prep = connection.prepareStatement(sql);
            prep.setInt(1, days - expiration);
            prep.executeUpdate();

        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
    }
}


########### LimitOrders.java

package me.bounser.nascraft.database.commands;

import me.bounser.nascraft.market.MarketManager;
import me.bounser.nascraft.market.limitorders.LimitOrder;
import me.bounser.nascraft.market.limitorders.LimitOrdersManager;
import me.bounser.nascraft.market.limitorders.OrderType;
import me.bounser.nascraft.market.unit.Item;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.time.LocalDateTime;
import java.util.UUID;

public class LimitOrders {

    public static void addLimitOrder(Connection connection, UUID uuid, LocalDateTime expiration, Item item, int type, double price, int amount) {

        try {
            String sql = "INSERT INTO limit_orders (expiration, uuid, identifier, type, price, to_complete, completed, cost) VALUES (?, ?, ?, ?, ?, ?, ?, ?);";

            PreparedStatement prep = connection.prepareStatement(sql);
            prep.setString(1, expiration.toString());
            prep.setString(2, uuid.toString());
            prep.setString(3, item.getIdentifier());
            prep.setInt(4, type);
            prep.setDouble(5, price);
            prep.setInt(6, amount);
            prep.setInt(7, 0);
            prep.setDouble(8, 0);
            prep.executeUpdate();

        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
    }

    public static void updateLimitOrder(Connection connection, UUID uuid, Item item, int completed, double cost) {

        try {
            String sql = "UPDATE limit_orders SET completed=?, cost=? WHERE uuid=? AND identifier=?;";

            PreparedStatement prep = connection.prepareStatement(sql);
            prep.setInt(1, completed);
            prep.setDouble(2, cost);
            prep.setString(3, uuid.toString());
            prep.setString(4, item.getIdentifier());
            prep.executeUpdate();

        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
    }

    public static void removeLimitOrder(Connection connection, String uuid, String identifier) {

        try {
            String sql = "DELETE FROM limit_orders WHERE uuid = ? AND identifier = ?;";

            PreparedStatement prep = connection.prepareStatement(sql);
            prep.setString(1, uuid);
            prep.setString(2, identifier);
            prep.executeUpdate();

        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
    }

    public static void retrieveLimitOrders(Connection connection) {

        try {
            String sql = "SELECT expiration, uuid, identifier, type, cost, price, to_complete, completed FROM limit_orders;";
            PreparedStatement prep = connection.prepareStatement(sql);
            ResultSet resultSet = prep.executeQuery();

            while (resultSet.next()) {

                LimitOrdersManager.getInstance().registerLimitOrder(
                        new LimitOrder(
                                UUID.fromString(resultSet.getString("uuid")),
                                MarketManager.getInstance().getItem(resultSet.getString("identifier")),
                                LocalDateTime.parse(resultSet.getString("expiration")),
                                resultSet.getInt("to_complete"),
                                resultSet.getInt("completed"),
                                resultSet.getDouble("price"),
                                resultSet.getDouble("cost"),
                                (resultSet.getInt("type") == 1 ? OrderType.LIMIT_BUY : OrderType.LIMIT_SELL)
                        )
                );
            }

        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
    }

}



########### TradesLog.java
package me.bounser.nascraft.database.commands;

import me.bounser.nascraft.config.Config;
import me.bounser.nascraft.database.commands.resources.NormalisedDate;
import me.bounser.nascraft.database.commands.resources.Trade;
import me.bounser.nascraft.formatter.RoundUtils;
import me.bounser.nascraft.market.MarketManager;
import me.bounser.nascraft.market.unit.Item;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.UUID;

public class TradesLog {

    public static void saveTrade(Connection connection, Trade trade) {
        try {
            String selectSQL = "INSERT INTO trade_log (uuid, day, date, identifier, amount, value, buy, discord) VALUES (?,?,?,?,?,?,?,?);";
            PreparedStatement statement = connection.prepareStatement(selectSQL);

            statement.setString(1, trade.getUuid().toString());
            statement.setInt(2, NormalisedDate.getDays());
            statement.setString(3, NormalisedDate.formatDateTime(LocalDateTime.now()));
            statement.setString(4, trade.getItem().getIdentifier());
            statement.setInt(5, trade.getAmount());
            statement.setFloat(6, RoundUtils.round(trade.getValue()));
            statement.setBoolean(7, trade.isBuy());
            statement.setBoolean(8, trade.throughDiscord());

            statement.executeUpdate();
        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
    }

    public static List<Trade> retrieveTrades(Connection connection, UUID uuid, int offset, int limit) {

        if (uuid == null) return null;

        try {
            List<Trade> trades = new ArrayList<>();
            String sql = "SELECT * FROM trade_log WHERE uuid = ? ORDER BY id DESC LIMIT " + limit + " OFFSET ?;";

            PreparedStatement statement = connection.prepareStatement(sql);
            statement.setString(1, uuid.toString());
            statement.setInt(2, offset);
            ResultSet rs = statement.executeQuery();
            while (rs.next()) {

                Trade trade = new Trade(
                        MarketManager.getInstance().getItem(rs.getString("identifier")),
                        NormalisedDate.parseDateTime(rs.getString("date")),
                        rs.getFloat("value"),
                        rs.getInt("amount"),
                        rs.getBoolean("buy"),
                        rs.getBoolean("discord"),
                        uuid
                );

                trades.add(trade);
            }
            return trades;

        } catch (SQLException e) {
            e.printStackTrace();
        }
        return null;
    }

    public static List<Trade> retrieveTrades(Connection connection, UUID uuid, Item item, int offset, int limit) {

        if (uuid == null) return null;

        try {
            List<Trade> trades = new ArrayList<>();
            String sql = "SELECT * FROM trade_log WHERE uuid = ? AND identifier = ? ORDER BY id DESC LIMIT " + limit + " OFFSET ?;";

            PreparedStatement statement = connection.prepareStatement(sql);
            statement.setString(1, uuid.toString());
            statement.setString(2, item.getIdentifier());
            statement.setInt(3, offset);
            ResultSet rs = statement.executeQuery();
            while (rs.next()) {

                Trade trade = new Trade(
                        MarketManager.getInstance().getItem(rs.getString("identifier")),
                        NormalisedDate.parseDateTime(rs.getString("date")),
                        rs.getFloat("value"),
                        rs.getInt("amount"),
                        rs.getBoolean("buy"),
                        rs.getBoolean("discord"),
                        uuid
                );

                trades.add(trade);
            }
            return trades;

        } catch (SQLException e) {
            e.printStackTrace();
        }
        return null;
    }

    public static List<Trade> retrieveTrades(Connection connection, Item item, int offset, int limit) {
        try {
            List<Trade> trades = new ArrayList<>();
            String sql = "SELECT * FROM trade_log WHERE identifier = ? ORDER BY id DESC LIMIT " + limit + " OFFSET ?;";

            PreparedStatement statement = connection.prepareStatement(sql);
            statement.setString(1, item.getIdentifier());
            statement.setInt(2, offset);
            ResultSet rs = statement.executeQuery();
            while (rs.next()) {

                Trade trade = new Trade(
                        item,
                        NormalisedDate.parseDateTime(rs.getString("date")),
                        rs.getFloat("value"),
                        rs.getInt("amount"),
                        rs.getBoolean("buy"),
                        rs.getBoolean("discord"),
                        UUID.fromString(rs.getString("uuid"))
                );

                trades.add(trade);
            }
            return trades;

        } catch (SQLException e) {
            e.printStackTrace();
        }
        return null;
    }

    public static List<Trade> retrieveLastTrades(Connection connection, int offset, int limit) {
        try {
            List<Trade> trades = new ArrayList<>();
            String sql = "SELECT * FROM trade_log ORDER BY id DESC LIMIT " + limit + " OFFSET ?;";

            PreparedStatement statement = connection.prepareStatement(sql);
            statement.setInt(1, offset);
            ResultSet rs = statement.executeQuery();
            while (rs.next()) {

                Trade trade = new Trade(
                        MarketManager.getInstance().getItem(rs.getString("identifier")),
                        NormalisedDate.parseDateTime(rs.getString("date")),
                        rs.getFloat("value"),
                        rs.getInt("amount"),
                        rs.getBoolean("buy"),
                        rs.getBoolean("discord"),
                        UUID.fromString(rs.getString("uuid"))
                );

                trades.add(trade);
            }
            return trades;

        } catch (SQLException e) {
            e.printStackTrace();
        }
        return null;
    }

    public static void purgeHistory(Connection connection) {

        int offset = Config.getInstance().getDatabasePurgeDays();
        if (offset == -1) return;

        try {
            String sql = "DELETE FROM trade_log WHERE day<?;";
            PreparedStatement prep = connection.prepareStatement(sql);
            prep.setDouble(1, NormalisedDate.getDays() - offset);
            prep.executeUpdate();
        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
    }

}
