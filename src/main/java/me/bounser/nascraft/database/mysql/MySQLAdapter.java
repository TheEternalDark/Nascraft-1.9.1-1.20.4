package me.bounser.nascraft.database.mysql;

import me.bounser.nascraft.Nascraft;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;
import java.util.regex.Pattern;

/**
 * Adaptador para adicionar prefixo às consultas SQL
 */
public class MySQLAdapter {

    private static final String TABLE_PREFIX = "nascraft_";

    // Set de tabelas para busca mais eficiente
    private static final Set<String> TABLES = new HashSet<>(Arrays.asList(
            "items", "prices_day", "prices_month", "prices_history",
            "portfolios", "portfolios_log", "portfolios_worth", "capacities",
            "discord_links", "trade_log", "cpi", "alerts", "flows",
            "limit_orders", "loans", "interests", "user_names"
    ));

    // Padrões regex compilados para melhor performance
    private static final Pattern[] TABLE_PATTERNS = TABLES.stream()
            .map(table -> Pattern.compile("\\b" + Pattern.quote(table) + "\\b", Pattern.CASE_INSENSITIVE))
            .toArray(Pattern[]::new);

    /**
     * Adiciona o prefixo a todas as referências de tabela em uma consulta SQL
     * @param sql Consulta SQL original
     * @return Consulta SQL com prefixos adicionados
     */
    public static String addPrefix(String sql) {
        if (sql == null || sql.trim().isEmpty()) {
            return sql;
        }

        String result = sql;

        // Aplica os padrões regex para substituir nomes de tabelas
        for (int i = 0; i < TABLE_PATTERNS.length; i++) {
            String tableName = TABLES.toArray(new String[0])[i];
            result = TABLE_PATTERNS[i].matcher(result).replaceAll(TABLE_PREFIX + tableName);
        }

        return result;
    }

    /**
     * Versão otimizada que adiciona prefixo apenas se necessário
     * @param sql Consulta SQL original
     * @return Consulta SQL com prefixos adicionados se necessário
     */
    public static String addPrefixIfNeeded(String sql) {
        if (sql == null || sql.trim().isEmpty()) {
            return sql;
        }

        // Verifica se já contém o prefixo
        if (sql.contains(TABLE_PREFIX)) {
            return sql;
        }

        return addPrefix(sql);
    }

    /**
     * Cria um PreparedStatement com prefixo adicionado à consulta SQL
     * @param connection Conexão com o banco de dados
     * @param sql Consulta SQL original
     * @return PreparedStatement com prefixo adicionado
     * @throws SQLException Se ocorrer um erro ao criar o PreparedStatement
     */
    public static PreparedStatement prepareStatement(Connection connection, String sql) throws SQLException {
        if (connection == null) {
            throw new SQLException("Connection cannot be null");
        }

        try {
            String prefixedSql = addPrefix(sql);
            return connection.prepareStatement(prefixedSql);
        } catch (SQLException e) {
            Nascraft.getInstance().getLogger().severe("Error preparing statement: " + e.getMessage());
            throw e;
        }
    }

    /**
     * Cria um PreparedStatement com opções adicionais
     * @param connection Conexão com o banco de dados
     * @param sql Consulta SQL original
     * @param resultSetType Tipo do ResultSet
     * @param resultSetConcurrency Concorrência do ResultSet
     * @return PreparedStatement com prefixo adicionado
     * @throws SQLException Se ocorrer um erro ao criar o PreparedStatement
     */
    public static PreparedStatement prepareStatement(Connection connection, String sql,
                                                     int resultSetType, int resultSetConcurrency) throws SQLException {
        if (connection == null) {
            throw new SQLException("Connection cannot be null");
        }

        try {
            String prefixedSql = addPrefix(sql);
            return connection.prepareStatement(prefixedSql, resultSetType, resultSetConcurrency);
        } catch (SQLException e) {
            Nascraft.getInstance().getLogger().severe("Error preparing statement with options: " + e.getMessage());
            throw e;
        }
    }

    /**
     * Cria um PreparedStatement para retornar chaves geradas automaticamente
     * @param connection Conexão com o banco de dados
     * @param sql Consulta SQL original
     * @param autoGeneratedKeys Flag para chaves geradas automaticamente
     * @return PreparedStatement com prefixo adicionado
     * @throws SQLException Se ocorrer um erro ao criar o PreparedStatement
     */
    public static PreparedStatement prepareStatement(Connection connection, String sql,
                                                     int autoGeneratedKeys) throws SQLException {
        if (connection == null) {
            throw new SQLException("Connection cannot be null");
        }

        try {
            String prefixedSql = addPrefix(sql);
            return connection.prepareStatement(prefixedSql, autoGeneratedKeys);
        } catch (SQLException e) {
            Nascraft.getInstance().getLogger().severe("Error preparing statement with auto-generated keys: " + e.getMessage());
            throw e;
        }
    }

    /**
     * Executa uma consulta SQL com prefixo adicionado
     * @param statement Statement para executar a consulta
     * @param sql Consulta SQL original
     * @return ResultSet com os resultados da consulta
     * @throws SQLException Se ocorrer um erro ao executar a consulta
     */
    public static ResultSet executeQuery(Statement statement, String sql) throws SQLException {
        if (statement == null) {
            throw new SQLException("Statement cannot be null");
        }

        try {
            String prefixedSql = addPrefix(sql);
            return statement.executeQuery(prefixedSql);
        } catch (SQLException e) {
            Nascraft.getInstance().getLogger().severe("Error executing query: " + e.getMessage());
            throw e;
        }
    }

    /**
     * Executa uma atualização SQL com prefixo adicionado
     * @param statement Statement para executar a atualização
     * @param sql Consulta SQL original
     * @return Número de linhas afetadas
     * @throws SQLException Se ocorrer um erro ao executar a atualização
     */
    public static int executeUpdate(Statement statement, String sql) throws SQLException {
        if (statement == null) {
            throw new SQLException("Statement cannot be null");
        }

        try {
            String prefixedSql = addPrefix(sql);
            return statement.executeUpdate(prefixedSql);
        } catch (SQLException e) {
            Nascraft.getInstance().getLogger().severe("Error executing update: " + e.getMessage());
            throw e;
        }
    }

    /**
     * Executa qualquer tipo de comando SQL com prefixo adicionado
     * @param statement Statement para executar o comando
     * @param sql Consulta SQL original
     * @return true se o primeiro resultado é um ResultSet, false se é um update count ou não há resultados
     * @throws SQLException Se ocorrer um erro ao executar o comando
     */
    public static boolean execute(Statement statement, String sql) throws SQLException {
        if (statement == null) {
            throw new SQLException("Statement cannot be null");
        }

        try {
            String prefixedSql = addPrefix(sql);
            return statement.execute(prefixedSql);
        } catch (SQLException e) {
            Nascraft.getInstance().getLogger().severe("Error executing statement: " + e.getMessage());
            throw e;
        }
    }

    /**
     * Verifica se uma consulta SQL contém referências a tabelas do Nascraft
     * @param sql Consulta SQL para verificar
     * @return true se contém referências a tabelas do Nascraft
     */
    public static boolean containsNascraftTables(String sql) {
        if (sql == null || sql.trim().isEmpty()) {
            return false;
        }

        String lowerSql = sql.toLowerCase();
        return TABLES.stream().anyMatch(table ->
                lowerSql.matches(".*\\b" + table + "\\b.*"));
    }

    /**
     * Remove o prefixo das tabelas (útil para logging ou debug)
     * @param sql Consulta SQL com prefixo
     * @return Consulta SQL sem prefixo
     */
    public static String removePrefix(String sql) {
        if (sql == null || sql.trim().isEmpty()) {
            return sql;
        }

        String result = sql;
        for (String table : TABLES) {
            result = result.replaceAll("\\b" + Pattern.quote(TABLE_PREFIX + table) + "\\b", table);
        }

        return result;
    }

    /**
     * Obtém o prefixo usado nas tabelas
     * @return O prefixo das tabelas
     */
    public static String getTablePrefix() {
        return TABLE_PREFIX;
    }

    /**
     * Obtém o conjunto de todas as tabelas conhecidas
     * @return Set com nomes das tabelas (sem prefixo)
     */
    public static Set<String> getKnownTables() {
        return new HashSet<>(TABLES);
    }

    /**
     * Valida se uma consulta SQL é segura (básica validação)
     * @param sql Consulta SQL para validar
     * @return true se a consulta parece segura
     */
    public static boolean isQuerySafe(String sql) {
        if (sql == null || sql.trim().isEmpty()) {
            return false;
        }

        String lowerSql = sql.toLowerCase().trim();

        // Verifica comandos perigosos
        String[] dangerousCommands = {
                "drop", "truncate", "delete from", "alter table",
                "create table", "grant", "revoke"
        };

        for (String dangerous : dangerousCommands) {
            if (lowerSql.startsWith(dangerous)) {
                return false;
            }
        }

        return true;
    }
}