package me.bounser.nascraft.database.mysql;

import com.zaxxer.hikari.HikariConfig;
import com.zaxxer.hikari.HikariDataSource;
import me.bounser.nascraft.Nascraft;
import me.bounser.nascraft.chart.cpi.CPIInstant;
import me.bounser.nascraft.config.Config;
import me.bounser.nascraft.database.Database;
import me.bounser.nascraft.database.commands.resources.DayInfo;
import me.bounser.nascraft.database.commands.resources.NormalisedDate;
import me.bounser.nascraft.database.commands.resources.Trade;
import me.bounser.nascraft.market.MarketManager;
import me.bounser.nascraft.market.unit.Item;
import me.bounser.nascraft.market.unit.stats.Instant;
import me.bounser.nascraft.portfolio.Portfolio;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.time.LocalDateTime;
import java.util.*;
import java.util.logging.Level;

public class MySQL implements Database {

    private final String HOST;
    private final int PORT;
    private final String DATABASE;
    private final String USERNAME;
    private final String PASSWORD;

    private HikariDataSource hikari;

    // Prefixo para todas as tabelas
    private static final String TABLE_PREFIX = "nascraft_";

    public MySQL(String host, int port, String database, String username, String password) {
        this.HOST = host;
        this.PORT = port;
        this.DATABASE = database;
        this.USERNAME = username;
        this.PASSWORD = password;
    }

    @Override
    public void connect() {
        try {
            HikariConfig config = new HikariConfig();
            config.setDriverClassName("com.mysql.cj.jdbc.Driver");
            config.setJdbcUrl("jdbc:mysql://" + HOST + ":" + PORT + "/" + DATABASE + "?useSSL=false&serverTimezone=UTC&useUnicode=true&characterEncoding=utf8");
            config.setUsername(USERNAME);
            config.setPassword(PASSWORD);

            // Connection pool settings
            config.setMaximumPoolSize(10);
            config.setMinimumIdle(2);
            config.setIdleTimeout(300000); // 5 minutes
            config.setConnectionTimeout(10000); // 10 seconds
            config.setLeakDetectionThreshold(60000); // 1 minute

            // MySQL specific settings
            config.addDataSourceProperty("cachePrepStmts", "true");
            config.addDataSourceProperty("prepStmtCacheSize", "250");
            config.addDataSourceProperty("prepStmtCacheSqlLimit", "2048");
            config.addDataSourceProperty("useServerPrepStmts", "true");
            config.addDataSourceProperty("useLocalSessionState", "true");
            config.addDataSourceProperty("rewriteBatchedStatements", "true");
            config.addDataSourceProperty("cacheResultSetMetadata", "true");
            config.addDataSourceProperty("cacheServerConfiguration", "true");
            config.addDataSourceProperty("elideSetAutoCommits", "true");
            config.addDataSourceProperty("maintainTimeStats", "false");

            hikari = new HikariDataSource(config);

            // Test connection and create tables
            try (Connection connection = getConnection()) {
                createTables();
                Nascraft.getInstance().getLogger().info("Successfully connected to MySQL database!");
            }
        } catch (SQLException e) {
            Nascraft.getInstance().getLogger().log(Level.SEVERE, "Failed to connect to MySQL database: " + e.getMessage(), e);
        }
    }

    @Override
    public void disconnect() {
        if (isConnected()) {
            saveEverything();
            hikari.close();
            Nascraft.getInstance().getLogger().info("MySQL connection closed");
        }
    }

    @Override
    public boolean isConnected() {
        return hikari != null && !hikari.isClosed();
    }

    private Connection getConnection() throws SQLException {
        if (!isConnected()) {
            throw new SQLException("Connection pool is not initialized");
        }
        return hikari.getConnection();
    }

    @Override
    public void createTables() {
        try (Connection connection = getConnection()) {
            // Create all tables with MySQL-specific syntax and nascraft_ prefix

            // Items table
            createTable(connection, TABLE_PREFIX + "items",
                    "identifier VARCHAR(255) PRIMARY KEY, " +
                            "lastprice DOUBLE, " +
                            "lowest DOUBLE, " +
                            "highest DOUBLE, " +
                            "stock DOUBLE DEFAULT 0, " +
                            "taxes DOUBLE");

            // Price tables
            createTable(connection, TABLE_PREFIX + "prices_day",
                    "id INT AUTO_INCREMENT PRIMARY KEY, " +
                            "day INT, " +
                            "date TEXT," +
                            "identifier VARCHAR(255)," +
                            "price DOUBLE," +
                            "volume INT, " +
                            "INDEX idx_identifier_day (identifier, day)");

            createTable(connection, TABLE_PREFIX + "prices_month",
                    "id INT AUTO_INCREMENT PRIMARY KEY, " +
                            "day INT NOT NULL, " +
                            "date TEXT NOT NULL," +
                            "identifier VARCHAR(255) NOT NULL," +
                            "price DOUBLE NOT NULL," +
                            "volume INT NOT NULL, " +
                            "INDEX idx_identifier_day (identifier, day)");

            createTable(connection, TABLE_PREFIX + "prices_history",
                    "id INT AUTO_INCREMENT PRIMARY KEY, " +
                            "day INT," +
                            "date TEXT NOT NULL," +
                            "identifier VARCHAR(255)," +
                            "price DOUBLE," +
                            "volume INT, " +
                            "INDEX idx_identifier_day (identifier, day)");

            // Portfolio tables
            createTable(connection, TABLE_PREFIX + "portfolios",
                    "uuid VARCHAR(36) NOT NULL," +
                            "identifier VARCHAR(255) NOT NULL," +
                            "amount INT, " +
                            "PRIMARY KEY (uuid, identifier)");

            createTable(connection, TABLE_PREFIX + "portfolios_log",
                    "id INT AUTO_INCREMENT PRIMARY KEY, " +
                            "uuid VARCHAR(36) NOT NULL," +
                            "day INT," +
                            "identifier VARCHAR(255)," +
                            "amount INT," +
                            "contribution DOUBLE, " +
                            "INDEX idx_uuid_day (uuid, day)");

            createTable(connection, TABLE_PREFIX + "portfolios_worth",
                    "id INT AUTO_INCREMENT PRIMARY KEY, " +
                            "uuid VARCHAR(36) NOT NULL," +
                            "day INT," +
                            "worth DOUBLE, " +
                            "UNIQUE KEY unique_uuid_day (uuid, day), " +
                            "INDEX idx_day (day)");

            createTable(connection, TABLE_PREFIX + "capacities",
                    "uuid VARCHAR(36) PRIMARY KEY," +
                            "capacity INT");

            // Discord link table
            createTable(connection, TABLE_PREFIX + "discord_links",
                    "userid VARCHAR(18) NOT NULL," +
                            "uuid VARCHAR(36) NOT NULL," +
                            "nickname TEXT NOT NULL, " +
                            "PRIMARY KEY (userid), " +
                            "UNIQUE KEY unique_uuid (uuid)");

            // Trade log table
            createTable(connection, TABLE_PREFIX + "trade_log",
                    "id INT AUTO_INCREMENT PRIMARY KEY, " +
                            "uuid VARCHAR(36) NOT NULL," +
                            "day INT NOT NULL," +
                            "date TEXT NOT NULL," +
                            "identifier VARCHAR(255) NOT NULL," +
                            "amount INT NOT NULL," +
                            "value DOUBLE NOT NULL," +
                            "buy BOOLEAN NOT NULL, " +
                            "discord BOOLEAN NOT NULL, " +
                            "INDEX idx_uuid (uuid), " +
                            "INDEX idx_identifier (identifier), " +
                            "INDEX idx_day (day)");

            // CPI table
            createTable(connection, TABLE_PREFIX + "cpi",
                    "day INT NOT NULL," +
                            "date TEXT NOT NULL," +
                            "value DOUBLE NOT NULL, " +
                            "PRIMARY KEY (day)");

            // Alerts table
            createTable(connection, TABLE_PREFIX + "alerts",
                    "day INT NOT NULL," +
                            "userid VARCHAR(36) NOT NULL," +
                            "identifier VARCHAR(255) NOT NULL," +
                            "price DOUBLE NOT NULL, " +
                            "PRIMARY KEY (userid, identifier), " +
                            "INDEX idx_day (day)");

            // Flows table
            createTable(connection, TABLE_PREFIX + "flows",
                    "day INT PRIMARY KEY," +
                            "flow DOUBLE NOT NULL," +
                            "taxes DOUBLE NOT NULL," +
                            "operations INT NOT NULL");

            // Limit orders table
            createTable(connection, TABLE_PREFIX + "limit_orders",
                    "id INT AUTO_INCREMENT PRIMARY KEY, " +
                            "expiration TEXT NOT NULL," +
                            "uuid VARCHAR(36) NOT NULL," +
                            "identifier VARCHAR(255) NOT NULL," +
                            "type INT NOT NULL," +
                            "price DOUBLE NOT NULL," +
                            "to_complete INT NOT NULL," +
                            "completed INT NOT NULL," +
                            "cost DOUBLE NOT NULL, " +
                            "INDEX idx_uuid_identifier (uuid, identifier)");

            // Loans table
            createTable(connection, TABLE_PREFIX + "loans",
                    "id INT AUTO_INCREMENT PRIMARY KEY, " +
                            "uuid VARCHAR(36) NOT NULL," +
                            "debt DOUBLE NOT NULL, " +
                            "UNIQUE KEY unique_uuid (uuid)");

            // Interests table
            createTable(connection, TABLE_PREFIX + "interests",
                    "id INT AUTO_INCREMENT PRIMARY KEY, " +
                            "uuid VARCHAR(36) NOT NULL," +
                            "paid DOUBLE NOT NULL, " +
                            "UNIQUE KEY unique_uuid (uuid)");

            // User names table
            createTable(connection, TABLE_PREFIX + "user_names",
                    "id INT AUTO_INCREMENT PRIMARY KEY, " +
                            "uuid VARCHAR(36) NOT NULL," +
                            "name TEXT NOT NULL, " +
                            "UNIQUE KEY unique_uuid (uuid)");

        } catch (SQLException e) {
            Nascraft.getInstance().getLogger().severe("Failed to create tables: " + e.getMessage());
        }
    }

    private void createTable(Connection connection, String tableName, String columns) {
        try (Statement statement = connection.createStatement()) {
            statement.execute("CREATE TABLE IF NOT EXISTS " + tableName + " (" + columns + ") ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;");
        } catch (SQLException e) {
            Nascraft.getInstance().getLogger().severe("Failed to create table " + tableName + ": " + e.getMessage());
        }
    }

    @Override
    public void saveEverything() {
        for (Item item : MarketManager.getInstance().getAllParentItems()) {
            try (Connection connection = getConnection()) {
                saveItem(connection, item);
            } catch (SQLException e) {
                Nascraft.getInstance().getLogger().warning(e.getMessage());
            }
        }
    }

    // Método auxiliar para salvar item com prefixo de tabela
    private void saveItem(Connection connection, Item item) {
        try {
            // Use MySQL-specific implementation for better performance
            String sql = "INSERT INTO " + TABLE_PREFIX + "items (identifier, lastprice, lowest, highest, stock, taxes) VALUES (?,?,?,?,?,?) " +
                    "ON DUPLICATE KEY UPDATE lastprice=VALUES(lastprice), lowest=VALUES(lowest), " +
                    "highest=VALUES(highest), stock=VALUES(stock), taxes=VALUES(taxes)";

            try (PreparedStatement prep = connection.prepareStatement(sql)) {
                prep.setString(1, item.getIdentifier());
                prep.setDouble(2, item.getPrice().getValue());
                prep.setDouble(3, item.getPrice().getHistoricalLow());
                prep.setDouble(4, item.getPrice().getHistoricalHigh());
                prep.setDouble(5, item.getPrice().getStock());
                prep.setDouble(6, item.getCollectedTaxes());
                prep.executeUpdate();
            }
        } catch (SQLException e) {
            Nascraft.getInstance().getLogger().warning("Error saving item: " + e.getMessage());
        }
    }

    // Discord Link methods
    @Override
    public void saveLink(String userId, UUID uuid, String nickname) {
        try (Connection connection = getConnection()) {
            // Use MySQL-specific REPLACE INTO to handle duplicate keys
            String sql = "REPLACE INTO " + TABLE_PREFIX + "discord_links (userid, uuid, nickname) VALUES (?,?,?);";
            try (PreparedStatement prep = connection.prepareStatement(sql)) {
                prep.setString(1, userId);
                prep.setString(2, uuid.toString());
                prep.setString(3, nickname);
                prep.executeUpdate();
            }
        } catch (SQLException e) {
            Nascraft.getInstance().getLogger().warning("Error saving Discord link: " + e.getMessage());
        }
    }

    @Override
    public void removeLink(String userId) {
        try (Connection connection = getConnection()) {
            String sql = "DELETE FROM " + TABLE_PREFIX + "discord_links WHERE userid=?;";
            try (PreparedStatement prep = connection.prepareStatement(sql)) {
                prep.setString(1, userId);
                prep.executeUpdate();
            }
        } catch (SQLException e) {
            Nascraft.getInstance().getLogger().warning(e.getMessage());
        }
    }

    @Override
    public UUID getUUID(String userId) {
        try (Connection connection = getConnection()) {
            String sql = "SELECT uuid FROM " + TABLE_PREFIX + "discord_links WHERE userid=?;";
            try (PreparedStatement prep = connection.prepareStatement(sql)) {
                prep.setString(1, userId);
                ResultSet resultSet = prep.executeQuery();

                if (resultSet.next()) {
                    return UUID.fromString(resultSet.getString("uuid"));
                }
                else {
                    return null;
                }
            }
        } catch (SQLException e) {
            Nascraft.getInstance().getLogger().warning(e.getMessage());
            return null;
        }
    }

    @Override
    public String getNickname(String userId) {
        try (Connection connection = getConnection()) {
            String sql = "SELECT nickname FROM " + TABLE_PREFIX + "discord_links WHERE userid=?;";
            try (PreparedStatement prep = connection.prepareStatement(sql)) {
                prep.setString(1, userId);
                ResultSet resultSet = prep.executeQuery();

                if (resultSet.next()) {
                    return resultSet.getString("nickname");
                }
                else {
                    return null;
                }
            }
        } catch (SQLException e) {
            Nascraft.getInstance().getLogger().warning(e.getMessage());
            return null;
        }
    }

    @Override
    public String getUserId(UUID uuid) {
        try (Connection connection = getConnection()) {
            String sql = "SELECT userid FROM " + TABLE_PREFIX + "discord_links WHERE uuid=?;";
            try (PreparedStatement prep = connection.prepareStatement(sql)) {
                prep.setString(1, uuid.toString());
                ResultSet resultSet = prep.executeQuery();

                if (resultSet.next()) {
                    return resultSet.getString("userid");
                } else {
                    return null;
                }
            }
        } catch (SQLException e) {
            Nascraft.getInstance().getLogger().warning(e.getMessage());
            return null;
        }
    }

    // Historical Data methods
    @Override
    public void saveDayPrice(Item item, Instant instant) {
        try (Connection connection = getConnection()) {
            String sql = "INSERT INTO " + TABLE_PREFIX + "prices_day (day, date, identifier, price, volume) VALUES (?, ?, ?, ?, ?);";
            try (PreparedStatement prep = connection.prepareStatement(sql)) {
                // Corrigido: usando métodos corretos da classe Instant
                prep.setInt(1, NormalisedDate.getDays());
                prep.setString(2, instant.getLocalDateTime().toString());
                prep.setString(3, item.getIdentifier());
                prep.setDouble(4, instant.getPrice());
                prep.setInt(5, instant.getVolume());
                prep.executeUpdate();
            }
        } catch (SQLException e) {
            Nascraft.getInstance().getLogger().warning(e.getMessage());
        }
    }

    @Override
    public void saveMonthPrice(Item item, Instant instant) {
        try (Connection connection = getConnection()) {
            String sql = "INSERT INTO " + TABLE_PREFIX + "prices_month (day, date, identifier, price, volume) VALUES (?, ?, ?, ?, ?);";
            try (PreparedStatement prep = connection.prepareStatement(sql)) {
                // Corrigido: usando métodos corretos da classe Instant
                prep.setInt(1, NormalisedDate.getDays());
                prep.setString(2, instant.getLocalDateTime().toString());
                prep.setString(3, item.getIdentifier());
                prep.setDouble(4, instant.getPrice());
                prep.setInt(5, instant.getVolume());
                prep.executeUpdate();
            }
        } catch (SQLException e) {
            Nascraft.getInstance().getLogger().warning(e.getMessage());
        }
    }

    @Override
    public void saveHistoryPrices(Item item, Instant instant) {
        try (Connection connection = getConnection()) {
            String sql = "INSERT INTO " + TABLE_PREFIX + "prices_history (day, date, identifier, price, volume) VALUES (?, ?, ?, ?, ?);";
            try (PreparedStatement prep = connection.prepareStatement(sql)) {
                // Corrigido: usando métodos corretos da classe Instant
                prep.setInt(1, NormalisedDate.getDays());
                prep.setString(2, instant.getLocalDateTime().toString());
                prep.setString(3, item.getIdentifier());
                prep.setDouble(4, instant.getPrice());
                prep.setInt(5, instant.getVolume());
                prep.executeUpdate();
            }
        } catch (SQLException e) {
            Nascraft.getInstance().getLogger().warning(e.getMessage());
        }
    }

    @Override
    public List<Instant> getDayPrices(Item item) {
        List<Instant> instants = new ArrayList<>();
        try (Connection connection = getConnection()) {
            String sql = "SELECT day, date, price, volume FROM " + TABLE_PREFIX + "prices_day WHERE identifier = ? ORDER BY day ASC;";
            try (PreparedStatement prep = connection.prepareStatement(sql)) {
                prep.setString(1, item.getIdentifier());
                ResultSet rs = prep.executeQuery();

                while (rs.next()) {
                    // Corrigido: ordem correta dos parâmetros (LocalDateTime, double, int)
                    instants.add(new Instant(
                            LocalDateTime.parse(rs.getString("date")),
                            rs.getDouble("price"),
                            rs.getInt("volume")
                    ));
                }
            }
        } catch (SQLException e) {
            Nascraft.getInstance().getLogger().warning(e.getMessage());
        }
        return instants;
    }

    @Override
    public List<Instant> getMonthPrices(Item item) {
        List<Instant> instants = new ArrayList<>();
        try (Connection connection = getConnection()) {
            String sql = "SELECT day, date, price, volume FROM " + TABLE_PREFIX + "prices_month WHERE identifier = ? ORDER BY day ASC;";
            try (PreparedStatement prep = connection.prepareStatement(sql)) {
                prep.setString(1, item.getIdentifier());
                ResultSet rs = prep.executeQuery();

                while (rs.next()) {
                    // Corrigido: ordem correta dos parâmetros (LocalDateTime, double, int)
                    instants.add(new Instant(
                            LocalDateTime.parse(rs.getString("date")),
                            rs.getDouble("price"),
                            rs.getInt("volume")
                    ));
                }
            }
        } catch (SQLException e) {
            Nascraft.getInstance().getLogger().warning(e.getMessage());
        }
        return instants;
    }

    @Override
    public List<Instant> getYearPrices(Item item) {
        List<Instant> instants = new ArrayList<>();
        try (Connection connection = getConnection()) {
            String sql = "SELECT day, date, price, volume FROM " + TABLE_PREFIX + "prices_history WHERE identifier = ? ORDER BY day ASC;";
            try (PreparedStatement prep = connection.prepareStatement(sql)) {
                prep.setString(1, item.getIdentifier());
                ResultSet rs = prep.executeQuery();

                while (rs.next()) {
                    // Corrigido: ordem correta dos parâmetros (LocalDateTime, double, int)
                    instants.add(new Instant(
                            LocalDateTime.parse(rs.getString("date")),
                            rs.getDouble("price"),
                            rs.getInt("volume")
                    ));
                }
            }
        } catch (SQLException e) {
            Nascraft.getInstance().getLogger().warning(e.getMessage());
        }
        return instants;
    }

    @Override
    public List<Instant> getAllPrices(Item item) {
        List<Instant> instants = new ArrayList<>();
        try (Connection connection = getConnection()) {
            String sql = "SELECT day, date, price, volume FROM " + TABLE_PREFIX + "prices_history WHERE identifier = ? " +
                    "UNION ALL " +
                    "SELECT day, date, price, volume FROM " + TABLE_PREFIX + "prices_month WHERE identifier = ? " +
                    "UNION ALL " +
                    "SELECT day, date, price, volume FROM " + TABLE_PREFIX + "prices_day WHERE identifier = ? " +
                    "ORDER BY day ASC;";
            try (PreparedStatement prep = connection.prepareStatement(sql)) {
                prep.setString(1, item.getIdentifier());
                prep.setString(2, item.getIdentifier());
                prep.setString(3, item.getIdentifier());
                ResultSet rs = prep.executeQuery();

                while (rs.next()) {
                    // Corrigido: ordem correta dos parâmetros (LocalDateTime, double, int)
                    instants.add(new Instant(
                            LocalDateTime.parse(rs.getString("date")),
                            rs.getDouble("price"),
                            rs.getInt("volume")
                    ));
                }
            }
        } catch (SQLException e) {
            Nascraft.getInstance().getLogger().warning(e.getMessage());
        }
        return instants;
    }

    @Override
    public Double getPriceOfDay(String identifier, int day) {
        try (Connection connection = getConnection()) {
            String sql = "SELECT price FROM " + TABLE_PREFIX + "prices_day WHERE identifier = ? AND day = ?;";
            try (PreparedStatement prep = connection.prepareStatement(sql)) {
                prep.setString(1, identifier);
                prep.setInt(2, day);
                ResultSet rs = prep.executeQuery();

                if (rs.next()) {
                    return rs.getDouble("price");
                }
            }
        } catch (SQLException e) {
            Nascraft.getInstance().getLogger().warning(e.getMessage());
        }
        return 0.0;
    }

    @Override
    public void saveItem(Item item) {
        try (Connection connection = getConnection()) {
            saveItem(connection, item);
        } catch (SQLException e) {
            Nascraft.getInstance().getLogger().warning("Error saving item: " + e.getMessage());
        }
    }

    // Item Properties methods
    @Override
    public void retrieveItem(Item item) {
        try (Connection connection = getConnection()) {
            String sql = "SELECT lowest, highest, stock, taxes FROM " + TABLE_PREFIX + "items WHERE identifier=?;";
            try (PreparedStatement prep = connection.prepareStatement(sql)) {
                prep.setString(1, item.getIdentifier());
                ResultSet rs = prep.executeQuery();

                if (rs.next()) {
                    item.getPrice().setStock(rs.getInt("stock"));
                    item.getPrice().setHistoricalHigh(rs.getFloat("highest"));
                    item.getPrice().setHistoricalLow(rs.getFloat("lowest"));
                    item.setCollectedTaxes(rs.getFloat("taxes"));
                } else {
                    String sqlinsert = "INSERT INTO " + TABLE_PREFIX + "items (identifier, lastprice, lowest, highest, stock, taxes) VALUES (?,?,?,?,?,?);";

                    try (PreparedStatement insertPrep = connection.prepareStatement(sqlinsert)) {
                        insertPrep.setString(1, item.getIdentifier());
                        insertPrep.setFloat(2, Config.getInstance().getInitialPrice(item.getIdentifier()));
                        insertPrep.setFloat(3, Config.getInstance().getInitialPrice(item.getIdentifier()));
                        insertPrep.setFloat(4, Config.getInstance().getInitialPrice(item.getIdentifier()));
                        insertPrep.setFloat(5, 0);
                        insertPrep.setFloat(6, 0);

                        item.getPrice().setStock(0);
                        item.getPrice().setHistoricalHigh(Config.getInstance().getInitialPrice(item.getIdentifier()));
                        item.getPrice().setHistoricalLow(Config.getInstance().getInitialPrice(item.getIdentifier()));
                        item.setCollectedTaxes(0);

                        insertPrep.executeUpdate();
                    }
                }
            }
        } catch (SQLException e) {
            Nascraft.getInstance().getLogger().warning(e.getMessage());
        }
    }

    @Override
    public void retrieveItems() {
        try (Connection connection = getConnection()) {
            String selectSQL = "SELECT stock, identifier FROM " + TABLE_PREFIX + "items;";
            try (PreparedStatement preparedStatement = connection.prepareStatement(selectSQL)) {
                ResultSet resultSet = preparedStatement.executeQuery();

                while (resultSet.next()) {
                    String identifier = resultSet.getString("identifier");
                    Item item = MarketManager.getInstance().getItem(identifier);

                    if (item == null) continue;

                    if (item.isParent()) {
                        item.getPrice().setStock(resultSet.getFloat("stock"));
                    }
                }
            }
        } catch (SQLException e) {
            Nascraft.getInstance().getLogger().warning(e.getMessage());
        }
    }

    @Override
    public float retrieveLastPrice(Item item) {
        try (Connection connection = getConnection()) {
            String selectSQL = "SELECT lastprice FROM " + TABLE_PREFIX + "items WHERE identifier = ?;";
            try (PreparedStatement preparedStatement = connection.prepareStatement(selectSQL)) {
                preparedStatement.setString(1, item.getIdentifier());
                ResultSet resultSet = preparedStatement.executeQuery();

                if (resultSet.next()) {
                    return resultSet.getFloat("lastprice");
                } else {
                    return Config.getInstance().getInitialPrice(item.getIdentifier());
                }
            }
        } catch (SQLException e) {
            Nascraft.getInstance().getLogger().warning(e.getMessage());
            return Config.getInstance().getInitialPrice(item.getIdentifier());
        }
    }

    // Trade Log methods
    @Override
    public void saveTrade(Trade trade) {
        try (Connection connection = getConnection()) {
            String sql = "INSERT INTO " + TABLE_PREFIX + "trade_log (uuid, day, date, identifier, amount, value, buy, discord) VALUES (?, ?, ?, ?, ?, ?, ?, ?);";
            try (PreparedStatement prep = connection.prepareStatement(sql)) {
                prep.setString(1, trade.getUuid().toString());
                prep.setInt(2, NormalisedDate.getDays());
                prep.setString(3, trade.getDate().toString());
                prep.setString(4, trade.getItem().getIdentifier());
                prep.setInt(5, trade.getAmount());
                prep.setDouble(6, trade.getValue());
                prep.setBoolean(7, trade.isBuy());
                prep.setBoolean(8, trade.throughDiscord());
                prep.executeUpdate();
            }
        } catch (SQLException e) {
            Nascraft.getInstance().getLogger().warning(e.getMessage());
        }
    }

    @Override
    public List<Trade> retrieveTrades(UUID uuid, int offset, int limit) {
        List<Trade> trades = new ArrayList<>();
        try (Connection connection = getConnection()) {
            String sql = "SELECT date, identifier, amount, value, buy, discord FROM " + TABLE_PREFIX + "trade_log WHERE uuid = ? ORDER BY date DESC LIMIT ? OFFSET ?;";
            try (PreparedStatement prep = connection.prepareStatement(sql)) {
                prep.setString(1, uuid.toString());
                prep.setInt(2, limit);
                prep.setInt(3, offset);
                ResultSet rs = prep.executeQuery();

                while (rs.next()) {
                    Item item = MarketManager.getInstance().getItem(rs.getString("identifier"));
                    if (item == null) continue;

                    trades.add(new Trade(
                            item,
                            LocalDateTime.parse(rs.getString("date")),
                            rs.getDouble("value"),
                            rs.getInt("amount"),
                            rs.getBoolean("buy"),
                            rs.getBoolean("discord"),
                            uuid
                    ));
                }
            }
        } catch (SQLException e) {
            Nascraft.getInstance().getLogger().warning(e.getMessage());
        }
        return trades;
    }

    @Override
    public List<Trade> retrieveTrades(UUID uuid, Item item, int offset, int limit) {
        List<Trade> trades = new ArrayList<>();
        try (Connection connection = getConnection()) {
            String sql = "SELECT date, amount, value, buy, discord FROM " + TABLE_PREFIX + "trade_log WHERE uuid = ? AND identifier = ? ORDER BY date DESC LIMIT ? OFFSET ?;";
            try (PreparedStatement prep = connection.prepareStatement(sql)) {
                prep.setString(1, uuid.toString());
                prep.setString(2, item.getIdentifier());
                prep.setInt(3, limit);
                prep.setInt(4, offset);
                ResultSet rs = prep.executeQuery();

                while (rs.next()) {
                    trades.add(new Trade(
                            item,
                            LocalDateTime.parse(rs.getString("date")),
                            rs.getDouble("value"),
                            rs.getInt("amount"),
                            rs.getBoolean("buy"),
                            rs.getBoolean("discord"),
                            uuid
                    ));
                }
            }
        } catch (SQLException e) {
            Nascraft.getInstance().getLogger().warning(e.getMessage());
        }
        return trades;
    }

    @Override
    public List<Trade> retrieveTrades(Item item, int offset, int limit) {
        List<Trade> trades = new ArrayList<>();
        try (Connection connection = getConnection()) {
            String sql = "SELECT uuid, date, amount, value, buy, discord FROM " + TABLE_PREFIX + "trade_log WHERE identifier = ? ORDER BY date DESC LIMIT ? OFFSET ?;";
            try (PreparedStatement prep = connection.prepareStatement(sql)) {
                prep.setString(1, item.getIdentifier());
                prep.setInt(2, limit);
                prep.setInt(3, offset);
                ResultSet rs = prep.executeQuery();

                while (rs.next()) {
                    trades.add(new Trade(
                            item,
                            LocalDateTime.parse(rs.getString("date")),
                            rs.getDouble("value"),
                            rs.getInt("amount"),
                            rs.getBoolean("buy"),
                            rs.getBoolean("discord"),
                            UUID.fromString(rs.getString("uuid"))
                    ));
                }
            }
        } catch (SQLException e) {
            Nascraft.getInstance().getLogger().warning(e.getMessage());
        }
        return trades;
    }

    @Override
    public List<Trade> retrieveTrades(int offset, int limit) {
        List<Trade> trades = new ArrayList<>();
        try (Connection connection = getConnection()) {
            String sql = "SELECT uuid, date, identifier, amount, value, buy, discord FROM " + TABLE_PREFIX + "trade_log ORDER BY date DESC LIMIT ? OFFSET ?;";
            try (PreparedStatement prep = connection.prepareStatement(sql)) {
                prep.setInt(1, limit);
                prep.setInt(2, offset);
                ResultSet rs = prep.executeQuery();

                while (rs.next()) {
                    Item item = MarketManager.getInstance().getItem(rs.getString("identifier"));
                    if (item == null) continue;

                    trades.add(new Trade(
                            item,
                            LocalDateTime.parse(rs.getString("date")),
                            rs.getDouble("value"),
                            rs.getInt("amount"),
                            rs.getBoolean("buy"),
                            rs.getBoolean("discord"),
                            UUID.fromString(rs.getString("uuid"))
                    ));
                }
            }
        } catch (SQLException e) {
            Nascraft.getInstance().getLogger().warning(e.getMessage());
        }
        return trades;
    }

    @Override
    public void purgeHistory() {
        try (Connection connection = getConnection()) {
            // Optimize for MySQL with indexed column
            int daysToKeep = Nascraft.getInstance().getConfig().getInt("database.days-until-history-removed");
            if (daysToKeep == -1) return;

            int cutoffDay = NormalisedDate.getDays() - daysToKeep;
            String sql = "DELETE FROM " + TABLE_PREFIX + "trade_log WHERE day < ?";

            try (PreparedStatement prep = connection.prepareStatement(sql)) {
                prep.setInt(1, cutoffDay);
                int rowsDeleted = prep.executeUpdate();
                Nascraft.getInstance().getLogger().info("Purged " + rowsDeleted + " old trade records");
            }
        } catch (SQLException e) {
            Nascraft.getInstance().getLogger().warning(e.getMessage());
        }
    }

    // Portfolio methods
    @Override
    public void updateItemPortfolio(UUID uuid, Item item, int quantity) {
        try (Connection connection = getConnection()) {
            // Use MySQL-specific implementation for better performance
            String sql = "INSERT INTO " + TABLE_PREFIX + "portfolios (uuid, identifier, amount) VALUES (?,?,?) " +
                    "ON DUPLICATE KEY UPDATE amount=VALUES(amount)";

            try (PreparedStatement prep = connection.prepareStatement(sql)) {
                prep.setString(1, uuid.toString());
                prep.setString(2, item.getIdentifier());
                prep.setInt(3, quantity);
                prep.executeUpdate();
            }
        } catch (SQLException e) {
            Nascraft.getInstance().getLogger().warning("Error updating portfolio: " + e.getMessage());
        }
    }

    @Override
    public void removeItemPortfolio(UUID uuid, Item item) {
        try (Connection connection = getConnection()) {
            String sql = "DELETE FROM " + TABLE_PREFIX + "portfolios WHERE uuid = ? AND identifier = ?;";
            try (PreparedStatement prep = connection.prepareStatement(sql)) {
                prep.setString(1, uuid.toString());
                prep.setString(2, item.getIdentifier());
                prep.executeUpdate();
            }
        } catch (SQLException e) {
            Nascraft.getInstance().getLogger().warning(e.getMessage());
        }
    }

    @Override
    public void clearPortfolio(UUID uuid) {
        try (Connection connection = getConnection()) {
            String sql = "DELETE FROM " + TABLE_PREFIX + "portfolios WHERE uuid = ?;";
            try (PreparedStatement prep = connection.prepareStatement(sql)) {
                prep.setString(1, uuid.toString());
                prep.executeUpdate();
            }
        } catch (SQLException e) {
            Nascraft.getInstance().getLogger().warning(e.getMessage());
        }
    }

    @Override
    public void updateCapacity(UUID uuid, int capacity) {
        try (Connection connection = getConnection()) {
            // Use MySQL-specific implementation for better performance
            String sql = "INSERT INTO " + TABLE_PREFIX + "capacities (uuid, capacity) VALUES (?,?) " +
                    "ON DUPLICATE KEY UPDATE capacity=VALUES(capacity)";

            try (PreparedStatement prep = connection.prepareStatement(sql)) {
                prep.setString(1, uuid.toString());
                prep.setInt(2, capacity);
                prep.executeUpdate();
            }
        } catch (SQLException e) {
            Nascraft.getInstance().getLogger().warning("Error updating capacity: " + e.getMessage());
        }
    }

    @Override
    public LinkedHashMap<Item, Integer> retrievePortfolio(UUID uuid) {
        LinkedHashMap<Item, Integer> portfolio = new LinkedHashMap<>();
        try (Connection connection = getConnection()) {
            String sql = "SELECT identifier, amount FROM " + TABLE_PREFIX + "portfolios WHERE uuid = ?;";
            try (PreparedStatement prep = connection.prepareStatement(sql)) {
                prep.setString(1, uuid.toString());
                ResultSet rs = prep.executeQuery();

                while (rs.next()) {
                    Item item = MarketManager.getInstance().getItem(rs.getString("identifier"));
                    if (item != null) {
                        portfolio.put(item, rs.getInt("amount"));
                    }
                }
            }
        } catch (SQLException e) {
            Nascraft.getInstance().getLogger().warning(e.getMessage());
        }
        return portfolio;
    }

    @Override
    public int retrieveCapacity(UUID uuid) {
        try (Connection connection = getConnection()) {
            String sql = "SELECT capacity FROM " + TABLE_PREFIX + "capacities WHERE uuid = ?;";
            try (PreparedStatement prep = connection.prepareStatement(sql)) {
                prep.setString(1, uuid.toString());
                ResultSet rs = prep.executeQuery();

                if (rs.next()) {
                    return rs.getInt("capacity");
                }
            }
        } catch (SQLException e) {
            Nascraft.getInstance().getLogger().warning(e.getMessage());
        }
        return 0;
    }

    // Debt methods
    @Override
    public void increaseDebt(UUID uuid, Double debt) {
        try (Connection connection = getConnection()) {
            // Use MySQL-specific implementation for better performance
            String sql = "INSERT INTO " + TABLE_PREFIX + "loans (uuid, debt) VALUES (?,?) " +
                    "ON DUPLICATE KEY UPDATE debt=debt+VALUES(debt)";

            try (PreparedStatement prep = connection.prepareStatement(sql)) {
                prep.setString(1, uuid.toString());
                prep.setDouble(2, debt);
                prep.executeUpdate();
            }
        } catch (SQLException e) {
            Nascraft.getInstance().getLogger().warning("Error increasing debt: " + e.getMessage());
        }
    }

    @Override
    public void decreaseDebt(UUID uuid, Double debt) {
        try (Connection connection = getConnection()) {
            String sql1 = "SELECT debt FROM " + TABLE_PREFIX + "loans WHERE uuid=?;";
            try (PreparedStatement prep1 = connection.prepareStatement(sql1)) {
                prep1.setString(1, uuid.toString());
                ResultSet resultSet = prep1.executeQuery();

                if(resultSet.next()) {
                    if (resultSet.getDouble("debt") - debt <= 0) {
                        String sql2 = "DELETE FROM " + TABLE_PREFIX + "loans WHERE uuid=?;";
                        try (PreparedStatement prep2 = connection.prepareStatement(sql2)) {
                            prep2.setString(1, uuid.toString());
                            prep2.executeUpdate();
                        }
                    } else {
                        String sql2 = "UPDATE " + TABLE_PREFIX + "loans SET debt=? WHERE uuid=?;";
                        try (PreparedStatement prep2 = connection.prepareStatement(sql2)) {
                            prep2.setDouble(1, resultSet.getDouble("debt") - debt);
                            prep2.setString(2, uuid.toString());
                            prep2.executeUpdate();
                        }
                    }
                }
            }
        } catch (SQLException e) {
            Nascraft.getInstance().getLogger().warning(e.getMessage());
        }
    }

    @Override
    public double getDebt(UUID uuid) {
        try (Connection connection = getConnection()) {
            String sql1 = "SELECT debt FROM " + TABLE_PREFIX + "loans WHERE uuid=?;";
            try (PreparedStatement prep1 = connection.prepareStatement(sql1)) {
                prep1.setString(1, uuid.toString());
                ResultSet resultSet = prep1.executeQuery();

                if(resultSet.next()) {
                    return resultSet.getDouble("debt");
                } else {
                    return 0;
                }
            }
        } catch (SQLException e) {
            Nascraft.getInstance().getLogger().warning(e.getMessage());
            return 0;
        }
    }

    @Override
    public HashMap<UUID, Double> getUUIDAndDebt() {
        HashMap<UUID, Double> debtors = new HashMap<>();
        try (Connection connection = getConnection()) {
            String sql = "SELECT uuid, debt FROM " + TABLE_PREFIX + "loans WHERE debt > 0;";
            try (PreparedStatement prep = connection.prepareStatement(sql)) {
                ResultSet rs = prep.executeQuery();

                while (rs.next()) {
                    String uuidString = rs.getString("uuid");
                    UUID uuid = UUID.fromString(uuidString);
                    Double debt = rs.getDouble("debt");
                    debtors.put(uuid, debt);
                }
            }
        } catch (SQLException e) {
            Nascraft.getInstance().getLogger().warning(e.getMessage());
        }
        return debtors;
    }

    @Override
    public void addInterestPaid(UUID uuid, Double interest) {
        try (Connection connection = getConnection()) {
            // Use MySQL-specific implementation for better performance
            String sql = "INSERT INTO " + TABLE_PREFIX + "interests (uuid, paid) VALUES (?,?) " +
                    "ON DUPLICATE KEY UPDATE paid=paid+VALUES(paid)";

            try (PreparedStatement prep = connection.prepareStatement(sql)) {
                prep.setString(1, uuid.toString());
                prep.setDouble(2, interest);
                prep.executeUpdate();
            }
        } catch (SQLException e) {
            Nascraft.getInstance().getLogger().warning("Error adding interest: " + e.getMessage());
        }
    }

    @Override
    public HashMap<UUID, Double> getUUIDAndInterestsPaid() {
        HashMap<UUID, Double> payers = new HashMap<>();
        try (Connection connection = getConnection()) {
            String sql = "SELECT uuid, paid FROM " + TABLE_PREFIX + "interests;";
            try (PreparedStatement prep = connection.prepareStatement(sql)) {
                ResultSet rs = prep.executeQuery();

                while (rs.next()) {
                    String uuidString = rs.getString("uuid");
                    UUID uuid = UUID.fromString(uuidString);
                    Double debt = rs.getDouble("paid");
                    payers.put(uuid, debt);
                }
            }
        } catch (SQLException e) {
            Nascraft.getInstance().getLogger().warning(e.getMessage());
        }
        return payers;
    }

    @Override
    public double getInterestsPaid(UUID uuid) {
        try (Connection connection = getConnection()) {
            String sql = "SELECT paid FROM " + TABLE_PREFIX + "interests WHERE uuid=?;";
            try (PreparedStatement prep = connection.prepareStatement(sql)) {
                prep.setString(1, uuid.toString());
                ResultSet rs = prep.executeQuery();

                if (rs.next())
                    return rs.getDouble("paid");
            }
        } catch (SQLException e) {
            Nascraft.getInstance().getLogger().warning(e.getMessage());
        }
        return 0;
    }

    @Override
    public double getAllOutstandingDebt() {
        try (Connection connection = getConnection()) {
            String sql = "SELECT SUM(debt) AS total_debt FROM " + TABLE_PREFIX + "loans;";
            try (PreparedStatement prep = connection.prepareStatement(sql)) {
                ResultSet rs = prep.executeQuery();

                if (rs.next())
                    return rs.getDouble("total_debt");
            }
        } catch (SQLException e) {
            Nascraft.getInstance().getLogger().warning(e.getMessage());
        }
        return 0;
    }

    @Override
    public double getAllInterestsPaid() {
        try (Connection connection = getConnection()) {
            String sql = "SELECT SUM(paid) AS total_paid FROM " + TABLE_PREFIX + "interests;";
            try (PreparedStatement prep = connection.prepareStatement(sql)) {
                ResultSet rs = prep.executeQuery();

                if (rs.next())
                    return rs.getDouble("total_paid");
            }
        } catch (SQLException e) {
            Nascraft.getInstance().getLogger().warning(e.getMessage());
        }
        return 0;
    }

    // Portfolio Worth methods
    @Override
    public void saveOrUpdateWorth(UUID uuid, int day, double worth) {
        try (Connection connection = getConnection()) {
            // Use MySQL-specific implementation for better performance
            String sql = "INSERT INTO " + TABLE_PREFIX + "portfolios_worth (uuid, day, worth) VALUES (?,?,?) " +
                    "ON DUPLICATE KEY UPDATE worth=VALUES(worth)";

            try (PreparedStatement prep = connection.prepareStatement(sql)) {
                prep.setString(1, uuid.toString());
                prep.setInt(2, day);
                prep.setDouble(3, worth);
                prep.executeUpdate();
            }
        } catch (SQLException e) {
            Nascraft.getInstance().getLogger().warning("Error saving portfolio worth: " + e.getMessage());
        }
    }

    @Override
    public void saveOrUpdateWorthToday(UUID uuid, double worth) {
        try (Connection connection = getConnection()) {
            int today = NormalisedDate.getDays();
            String sql = "INSERT INTO " + TABLE_PREFIX + "portfolios_worth (uuid, day, worth) VALUES (?,?,?) " +
                    "ON DUPLICATE KEY UPDATE worth=VALUES(worth)";

            try (PreparedStatement prep = connection.prepareStatement(sql)) {
                prep.setString(1, uuid.toString());
                prep.setInt(2, today);
                prep.setDouble(3, worth);
                prep.executeUpdate();
            }
        } catch (SQLException e) {
            Nascraft.getInstance().getLogger().warning(e.getMessage());
        }
    }

    @Override
    public HashMap<UUID, Portfolio> getTopWorth(int n) {
        HashMap<UUID, Portfolio> topPortfolios = new HashMap<>();
        try (Connection connection = getConnection()) {
            String sql = "SELECT pw.uuid, pw.worth, MAX(pw.day) as latest_day " +
                    "FROM " + TABLE_PREFIX + "portfolios_worth pw " +
                    "GROUP BY pw.uuid " +
                    "ORDER BY pw.worth DESC " +
                    "LIMIT ?";

            try (PreparedStatement prep = connection.prepareStatement(sql)) {
                prep.setInt(1, n);
                ResultSet rs = prep.executeQuery();

                while (rs.next()) {
                    UUID uuid = UUID.fromString(rs.getString("uuid"));
                    double worth = rs.getDouble("worth");

                    Portfolio portfolio = new Portfolio(uuid);
                    topPortfolios.put(uuid, portfolio);
                }
            }
        } catch (SQLException e) {
            Nascraft.getInstance().getLogger().warning(e.getMessage());
        }
        return topPortfolios;
    }

    @Override
    public double getLatestWorth(UUID uuid) {
        try (Connection connection = getConnection()) {
            String sql = "SELECT worth FROM " + TABLE_PREFIX + "portfolios_worth " +
                    "WHERE uuid = ? " +
                    "ORDER BY day DESC " +
                    "LIMIT 1";

            try (PreparedStatement prep = connection.prepareStatement(sql)) {
                prep.setString(1, uuid.toString());
                ResultSet rs = prep.executeQuery();

                if (rs.next()) {
                    return rs.getDouble("worth");
                }
            }
        } catch (SQLException e) {
            Nascraft.getInstance().getLogger().warning(e.getMessage());
        }
        return 0;
    }

    // Portfolio Log methods
    @Override
    public void logContribution(UUID uuid, Item item, int amount) {
        try (Connection connection = getConnection()) {
            int today = NormalisedDate.getDays();
            double contribution = amount * item.getPrice().getValue();

            String sql = "INSERT INTO " + TABLE_PREFIX + "portfolios_log (uuid, day, identifier, amount, contribution) " +
                    "VALUES (?, ?, ?, ?, ?)";

            try (PreparedStatement prep = connection.prepareStatement(sql)) {
                prep.setString(1, uuid.toString());
                prep.setInt(2, today);
                prep.setString(3, item.getIdentifier());
                prep.setInt(4, amount);
                prep.setDouble(5, contribution);
                prep.executeUpdate();
            }
        } catch (SQLException e) {
            Nascraft.getInstance().getLogger().warning(e.getMessage());
        }
    }

    @Override
    public void logWithdraw(UUID uuid, Item item, int amount) {
        try (Connection connection = getConnection()) {
            int today = NormalisedDate.getDays();
            double contribution = -1 * amount * item.getPrice().getValue();

            String sql = "INSERT INTO " + TABLE_PREFIX + "portfolios_log (uuid, day, identifier, amount, contribution) " +
                    "VALUES (?, ?, ?, ?, ?)";

            try (PreparedStatement prep = connection.prepareStatement(sql)) {
                prep.setString(1, uuid.toString());
                prep.setInt(2, today);
                prep.setString(3, item.getIdentifier());
                prep.setInt(4, -amount);
                prep.setDouble(5, contribution);
                prep.executeUpdate();
            }
        } catch (SQLException e) {
            Nascraft.getInstance().getLogger().warning(e.getMessage());
        }
    }

    @Override
    public HashMap<Integer, Double> getContributionChangeEachDay(UUID uuid) {
        HashMap<Integer, Double> contributions = new HashMap<>();
        try (Connection connection = getConnection()) {
            String sql = "SELECT day, SUM(contribution) as total_contribution " +
                    "FROM " + TABLE_PREFIX + "portfolios_log " +
                    "WHERE uuid = ? " +
                    "GROUP BY day " +
                    "ORDER BY day ASC";

            try (PreparedStatement prep = connection.prepareStatement(sql)) {
                prep.setString(1, uuid.toString());
                ResultSet rs = prep.executeQuery();

                while (rs.next()) {
                    int day = rs.getInt("day");
                    double contribution = rs.getDouble("total_contribution");
                    contributions.put(day, contribution);
                }
            }
        } catch (SQLException e) {
            Nascraft.getInstance().getLogger().warning(e.getMessage());
        }
        return contributions;
    }

    @Override
    public HashMap<Integer, HashMap<String, Integer>> getCompositionEachDay(UUID uuid) {
        HashMap<Integer, HashMap<String, Integer>> composition = new HashMap<>();
        try (Connection connection = getConnection()) {
            String sql = "SELECT day, identifier, SUM(amount) as total_amount " +
                    "FROM " + TABLE_PREFIX + "portfolios_log " +
                    "WHERE uuid = ? " +
                    "GROUP BY day, identifier " +
                    "ORDER BY day ASC";

            try (PreparedStatement prep = connection.prepareStatement(sql)) {
                prep.setString(1, uuid.toString());
                ResultSet rs = prep.executeQuery();

                while (rs.next()) {
                    int day = rs.getInt("day");
                    String identifier = rs.getString("identifier");
                    int amount = rs.getInt("total_amount");

                    if (!composition.containsKey(day)) {
                        composition.put(day, new HashMap<>());
                    }

                    composition.get(day).put(identifier, amount);
                }
            }
        } catch (SQLException e) {
            Nascraft.getInstance().getLogger().warning(e.getMessage());
        }
        return composition;
    }

    @Override
    public int getFirstDay(UUID uuid) {
        try (Connection connection = getConnection()) {
            String sql = "SELECT MIN(day) as first_day " +
                    "FROM " + TABLE_PREFIX + "portfolios_log " +
                    "WHERE uuid = ?";

            try (PreparedStatement prep = connection.prepareStatement(sql)) {
                prep.setString(1, uuid.toString());
                ResultSet rs = prep.executeQuery();

                if (rs.next()) {
                    return rs.getInt("first_day");
                }
            }
        } catch (SQLException e) {
            Nascraft.getInstance().getLogger().warning(e.getMessage());
        }
        return NormalisedDate.getDays();
    }

    // Statistics methods
    @Override
    public void saveCPIValue(float indexValue) {
        try (Connection connection = getConnection()) {
            // Use MySQL-specific implementation for better performance
            int today = NormalisedDate.getDays();
            String sql = "INSERT INTO " + TABLE_PREFIX + "cpi (day, date, value) VALUES (?,?,?) " +
                    "ON DUPLICATE KEY UPDATE date=VALUES(date), value=VALUES(value)";

            try (PreparedStatement prep = connection.prepareStatement(sql)) {
                prep.setInt(1, today);
                prep.setString(2, LocalDateTime.now().toString());
                prep.setFloat(3, indexValue);
                prep.executeUpdate();
            }
        } catch (SQLException e) {
            Nascraft.getInstance().getLogger().warning("Error saving CPI value: " + e.getMessage());
        }
    }

    @Override
    public List<CPIInstant> getCPIHistory() {
        List<CPIInstant> cpiInstants = new ArrayList<>();
        try (Connection connection = getConnection()) {
            // Use ORDER BY for consistent results
            String sql = "SELECT value, date FROM " + TABLE_PREFIX + "cpi ORDER BY day ASC";
            try (PreparedStatement prep = connection.prepareStatement(sql)) {
                ResultSet rs = prep.executeQuery();

                while (rs.next()) {
                    cpiInstants.add(new CPIInstant(
                            rs.getFloat("value"),
                            LocalDateTime.parse(rs.getString("date"))
                    ));
                }
            }
        } catch (SQLException e) {
            Nascraft.getInstance().getLogger().warning("Error retrieving CPI data: " + e.getMessage());
        }
        return cpiInstants;
    }

    @Override
    public List<Instant> getPriceAgainstCPI(Item item) {
        List<Instant> instants = new ArrayList<>();
        try (Connection connection = getConnection()) {
            String sql = "SELECT p.day, p.date, p.price, p.volume, c.value as cpi_value " +
                    "FROM " + TABLE_PREFIX + "prices_history p " +
                    "JOIN " + TABLE_PREFIX + "cpi c ON p.day = c.day " +
                    "WHERE p.identifier = ? " +
                    "ORDER BY p.day ASC";

            try (PreparedStatement prep = connection.prepareStatement(sql)) {
                prep.setString(1, item.getIdentifier());
                ResultSet rs = prep.executeQuery();

                while (rs.next()) {
                    float cpiValue = rs.getFloat("cpi_value");
                    float price = rs.getFloat("price");
                    float adjustedPrice = price / cpiValue;

                    // Corrigido: ordem correta dos parâmetros (LocalDateTime, double, int)
                    instants.add(new Instant(
                            LocalDateTime.parse(rs.getString("date")),
                            adjustedPrice,
                            rs.getInt("volume")
                    ));
                }
            }
        } catch (SQLException e) {
            Nascraft.getInstance().getLogger().warning(e.getMessage());
        }
        return instants;
    }

    @Override
    public void addTransaction(double newFlow, double effectiveTaxes) {
        try (Connection connection = getConnection()) {
            // Use MySQL-specific implementation for better performance
            int today = NormalisedDate.getDays();
            String sql = "INSERT INTO " + TABLE_PREFIX + "flows (day, flow, taxes, operations) VALUES (?,?,?,1) " +
                    "ON DUPLICATE KEY UPDATE flow=flow+?, taxes=taxes+?, operations=operations+1";

            try (PreparedStatement prep = connection.prepareStatement(sql)) {
                prep.setInt(1, today);
                prep.setDouble(2, newFlow);
                prep.setDouble(3, Math.abs(effectiveTaxes));
                prep.setDouble(4, newFlow);
                prep.setDouble(5, Math.abs(effectiveTaxes));
                prep.executeUpdate();
            }
        } catch (SQLException e) {
            Nascraft.getInstance().getLogger().warning("Error adding transaction: " + e.getMessage());
        }
    }

    @Override
    public List<DayInfo> getDayInfos() {
        List<DayInfo> dayInfos = new ArrayList<>();
        try (Connection connection = getConnection()) {
            String sql = "SELECT day, flow, taxes FROM " + TABLE_PREFIX + "flows ORDER BY day ASC";
            try (PreparedStatement prep = connection.prepareStatement(sql)) {
                ResultSet rs = prep.executeQuery();

                while (rs.next()) {
                    dayInfos.add(new DayInfo(
                            rs.getInt("day"),
                            rs.getDouble("flow"),
                            rs.getDouble("taxes")
                    ));
                }
            }
        } catch (SQLException e) {
            Nascraft.getInstance().getLogger().warning(e.getMessage());
        }
        return dayInfos;
    }

    @Override
    public double getAllTaxesCollected() {
        try (Connection connection = getConnection()) {
            String sql = "SELECT SUM(taxes) as total_taxes FROM " + TABLE_PREFIX + "flows";
            try (PreparedStatement prep = connection.prepareStatement(sql)) {
                ResultSet rs = prep.executeQuery();

                if (rs.next()) {
                    return rs.getDouble("total_taxes");
                }
            }
        } catch (SQLException e) {
            Nascraft.getInstance().getLogger().warning(e.getMessage());
        }
        return 0;
    }

    // Alerts methods
    @Override
    public void addAlert(String userid, Item item, double price) {
        try (Connection connection = getConnection()) {
            // Use MySQL-specific implementation for better performance
            String sql = "INSERT INTO " + TABLE_PREFIX + "alerts (day, userid, identifier, price) VALUES (?,?,?,?) " +
                    "ON DUPLICATE KEY UPDATE day=VALUES(day), price=VALUES(price)";

            try (PreparedStatement prep = connection.prepareStatement(sql)) {
                prep.setInt(1, NormalisedDate.getDays());
                prep.setString(2, userid);
                prep.setString(3, item.getIdentifier());
                prep.setDouble(4, price);
                prep.executeUpdate();
            }
        } catch (SQLException e) {
            Nascraft.getInstance().getLogger().warning("Error adding alert: " + e.getMessage());
        }
    }

    @Override
    public void removeAlert(String userid, Item item) {
        try (Connection connection = getConnection()) {
            String sql = "DELETE FROM " + TABLE_PREFIX + "alerts WHERE userid = ? AND identifier = ?;";
            try (PreparedStatement prep = connection.prepareStatement(sql)) {
                prep.setString(1, userid);
                prep.setString(2, item.getIdentifier());
                prep.executeUpdate();
            }
        } catch (SQLException e) {
            Nascraft.getInstance().getLogger().warning(e.getMessage());
        }
    }

    @Override
    public void retrieveAlerts() {
        try (Connection connection = getConnection()) {
            String sql = "SELECT userid, identifier, price FROM " + TABLE_PREFIX + "alerts;";
            try (PreparedStatement prep = connection.prepareStatement(sql)) {
                ResultSet resultSet = prep.executeQuery();

                while (resultSet.next()) {
                    // Implementação específica para recuperar alertas
                    // Aqui você precisaria chamar o método apropriado do DiscordAlerts
                    // DiscordAlerts.getInstance().setAlert(resultSet.getString("userid"), resultSet.getString("identifier"), resultSet.getDouble("price"));
                }
            }
        } catch (SQLException e) {
            Nascraft.getInstance().getLogger().warning(e.getMessage());
        }
    }

    @Override
    public void removeAllAlerts(String userId) {
        try (Connection connection = getConnection()) {
            String sql = "DELETE FROM " + TABLE_PREFIX + "alerts WHERE userid=?";
            try (PreparedStatement prep = connection.prepareStatement(sql)) {
                prep.setString(1, userId);
                prep.executeUpdate();
            }
        } catch (SQLException e) {
            Nascraft.getInstance().getLogger().warning(e.getMessage());
        }
    }

    @Override
    public void purgeAlerts() {
        try (Connection connection = getConnection()) {
            int expiration = Config.getInstance().getAlertsDaysUntilExpired();
            int days = NormalisedDate.getDays();

            String sql = "DELETE FROM " + TABLE_PREFIX + "alerts WHERE day < ?;";
            try (PreparedStatement prep = connection.prepareStatement(sql)) {
                prep.setInt(1, days - expiration);
                prep.executeUpdate();
            }
        } catch (SQLException e) {
            Nascraft.getInstance().getLogger().warning(e.getMessage());
        }
    }

    // Limit Orders methods
    @Override
    public void addLimitOrder(UUID uuid, LocalDateTime expiration, Item item, int type, double price, int amount) {
        try (Connection connection = getConnection()) {
            String sql = "INSERT INTO " + TABLE_PREFIX + "limit_orders (expiration, uuid, identifier, type, price, to_complete, completed, cost) VALUES (?, ?, ?, ?, ?, ?, ?, ?);";
            try (PreparedStatement prep = connection.prepareStatement(sql)) {
                prep.setString(1, expiration.toString());
                prep.setString(2, uuid.toString());
                prep.setString(3, item.getIdentifier());
                prep.setInt(4, type);
                prep.setDouble(5, price);
                prep.setInt(6, amount);
                prep.setInt(7, 0);
                prep.setDouble(8, 0);
                prep.executeUpdate();
            }
        } catch (SQLException e) {
            Nascraft.getInstance().getLogger().warning(e.getMessage());
        }
    }

    @Override
    public void updateLimitOrder(UUID uuid, Item item, int completed, double cost) {
        try (Connection connection = getConnection()) {
            String sql = "UPDATE " + TABLE_PREFIX + "limit_orders SET completed=?, cost=? WHERE uuid=? AND identifier=?;";
            try (PreparedStatement prep = connection.prepareStatement(sql)) {
                prep.setInt(1, completed);
                prep.setDouble(2, cost);
                prep.setString(3, uuid.toString());
                prep.setString(4, item.getIdentifier());
                prep.executeUpdate();
            }
        } catch (SQLException e) {
            Nascraft.getInstance().getLogger().warning(e.getMessage());
        }
    }

    @Override
    public void removeLimitOrder(String uuid, String identifier) {
        try (Connection connection = getConnection()) {
            String sql = "DELETE FROM " + TABLE_PREFIX + "limit_orders WHERE uuid = ? AND identifier = ?;";
            try (PreparedStatement prep = connection.prepareStatement(sql)) {
                prep.setString(1, uuid);
                prep.setString(2, identifier);
                prep.executeUpdate();
            }
        } catch (SQLException e) {
            Nascraft.getInstance().getLogger().warning(e.getMessage());
        }
    }

    @Override
    public void retrieveLimitOrders() {
        try (Connection connection = getConnection()) {
            String sql = "SELECT expiration, uuid, identifier, type, cost, price, to_complete, completed FROM " + TABLE_PREFIX + "limit_orders;";
            try (PreparedStatement prep = connection.prepareStatement(sql)) {
                ResultSet resultSet = prep.executeQuery();

                while (resultSet.next()) {
                    // Implementação específica para recuperar ordens limite
                    // Aqui você precisaria chamar o método apropriado do LimitOrdersManager
                    // LimitOrdersManager.getInstance().registerLimitOrder(...);
                }
            }
        } catch (SQLException e) {
            Nascraft.getInstance().getLogger().warning(e.getMessage());
        }
    }

    // User Names methods
    @Override
    public String getNameByUUID(UUID uuid) {
        try (Connection connection = getConnection()) {
            String sql = "SELECT name FROM " + TABLE_PREFIX + "user_names WHERE uuid=?;";
            try (PreparedStatement prep = connection.prepareStatement(sql)) {
                prep.setString(1, uuid.toString());
                ResultSet rs = prep.executeQuery();

                if (rs.next())
                    return rs.getString("name");
            }
        } catch (SQLException e) {
            Nascraft.getInstance().getLogger().warning(e.getMessage());
        }
        return " ";
    }

    @Override
    public void saveOrUpdateName(UUID uuid, String name) {
        try (Connection connection = getConnection()) {
            // Use MySQL-specific implementation for better performance
            String sql = "INSERT INTO " + TABLE_PREFIX + "user_names (uuid, name) VALUES (?,?) " +
                    "ON DUPLICATE KEY UPDATE name=VALUES(name)";

            try (PreparedStatement prep = connection.prepareStatement(sql)) {
                prep.setString(1, uuid.toString());
                prep.setString(2, name);
                prep.executeUpdate();
            }
        } catch (SQLException e) {
            Nascraft.getInstance().getLogger().warning("Error saving user name: " + e.getMessage());
        }
    }
}
